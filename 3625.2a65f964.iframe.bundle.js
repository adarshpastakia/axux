"use strict";(self.webpackChunkaxux=self.webpackChunkaxux||[]).push([[3625],{"./node_modules/@arcgis/core/layers/graphics/sources/support/uploadAssets.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{uploadAssets:()=>g});var request=__webpack_require__("./node_modules/@arcgis/core/request.js"),core_Error=__webpack_require__("./node_modules/@arcgis/core/core/Error.js"),Logger=__webpack_require__("./node_modules/@arcgis/core/core/Logger.js"),promiseUtils=__webpack_require__("./node_modules/@arcgis/core/core/promiseUtils.js"),urlUtils=__webpack_require__("./node_modules/@arcgis/core/core/urlUtils.js"),uuid=__webpack_require__("./node_modules/@arcgis/core/core/uuid.js"),External=__webpack_require__("./node_modules/@arcgis/core/geometry/support/meshUtils/External.js"),arcgisLayerUrl=__webpack_require__("./node_modules/@arcgis/core/layers/support/arcgisLayerUrl.js");const r=1e6,a=20*r,n=2e9,i=3;async function uploads_p({data:p,name:c,description:l},m,d){let f=null;try{const u=(0,urlUtils.v_)(m,"uploads"),h=(0,urlUtils.v_)(u,"info"),{data:w}=await(0,request.default)(h,{query:{f:"json"},responseType:"json"});(0,promiseUtils.k_)(d);const y=(0,arcgisLayerUrl.M8)(m),j=w.maxUploadFileSize*r,g=y?n:j,q=y?Math.min(a,j):a;if(p.size>g)throw new Error("Data too large");const T=(0,urlUtils.v_)(u,"register"),{data:z}=await(0,request.default)(T,{query:{f:"json",itemName:c,description:l},responseType:"json",method:"post"});if((0,promiseUtils.k_)(d),!z.success)throw new Error("Registration failed");const{itemID:E}=z.item;f=(0,urlUtils.v_)(u,E);const U=(0,urlUtils.v_)(f,"uploadPart"),D=Math.ceil(p.size/q),M=new Array;for(let e=0;e<D;++e)M.push(p.slice(e*q,Math.min((e+1)*q,p.size)));const P=M.slice().reverse(),x=new Array,A=async()=>{for(;0!==P.length;){const o=M.length-P.length,s=P.pop(),r=new FormData;r.append("f","json"),r.append("file",s),r.append("partId",`${o}`);const{data:a}=await(0,request.default)(U,{timeout:0,body:r,responseType:"json",method:"post"});if((0,promiseUtils.k_)(d),!a.success)throw new Error("Part upload failed")}};for(let e=0;e<i&&0!==P.length;++e)x.push(A());await Promise.all(x);const F=(0,urlUtils.v_)(f,"commit"),{data:I}=await(0,request.default)(F,{query:{f:"json",parts:M.map(((e,t)=>t)).join(",")},responseType:"json",method:"post"});if((0,promiseUtils.k_)(d),!I.success)throw new Error("Commit failed");return I.item}catch(u){if(null!=f){const t=(0,urlUtils.v_)(f,"delete");await(0,request.default)(t,{query:{f:"json"},responseType:"json",method:"post"})}throw u}}var infoFor3D=__webpack_require__("./node_modules/@arcgis/core/layers/support/infoFor3D.js");async function g(e,t,s){return e.length?Promise.all(e.map((e=>async function T(e,{layer:s,ongoingUploads:r},a){const o=r.get(e);if(o)return o;if(!function P(e){return!!e.infoFor3D&&!!e.url}(s))throw new core_Error.Z(`${s.type}-layer:upload-failure`,"Layer does not support asset uploads.",new Error);if(function b(e,t){const{parsedUrl:s}=t;return null!=s&&e.metadata.externalSources.some((e=>(0,External.JG)(e,s)))}(e,s))return e;const n=async function E(e,t,s){const{metadata:a}=e,{displaySource:o}=a,n=x(o?.source,t),i=!!n,u=a.externalSources.length>0,l=i?async function $(e,t,s){return{source:await N(e,t,s),original:!0}}(n,t,s):u?async function F(e,s,r){const a=B(s),{externalSources:o}=e.metadata,n=function U(e,t){for(const s of e){const e=x(s.source,t);if(e)return e}return null}(o,s);if(!n)throw new core_Error.Z(`${s.type}-layer:upload-failure`,"Could not find an external source that is supported by the service.",new Error);const i=await N(n,s,r);return e.addExternalSources([{source:i,original:!0}]),{source:await q(i,s,a)}}(e,t,s):async function j(e,t,s){const r=async function D(e,t,s){const a=B(t),o=await e.load(s),n=await o.toBinaryGLTF({ignoreLocalTransform:!0});(0,promiseUtils.k_)(s);const i=await n.buffer();return(0,promiseUtils.k_)(s),{blob:new Blob([i.data],{type:i.type}),assetName:`${(0,uuid.z)()}.glb`,assetType:a}}(e,t,s);return{source:await A([r],t,s),extent:e.extent.clone(),original:!0}}(e,t,s),c=await l;return(0,promiseUtils.k_)(s),e.addExternalSources([c]),e}(e,s,a);r.set(e,n);try{await n}finally{r.delete(e)}return e}(e,t,s)))):[]}function x(e,t){if(!e)return null;const{infoFor3D:{supportedFormats:s,editFormats:r}}=t,a=(0,External.zE)(e),o=new Array;let n=!1;for(let i=0;i<a.length;++i){const e=v(a[i],s);if(!e)return null;r.includes(e.assetType)&&(n=!0),o.push(e)}return n?o:null}function v(e,t){const s=(0,External.vj)(e,t);return s?{asset:e,assetType:s}:null}async function N(e,t,s){return A(e.map((e=>async function S(e,t){const{asset:s,assetType:a}=e;if(s instanceof File)return{blob:s,assetName:s.name,assetType:a};const o=await s.toBlob(t);return(0,promiseUtils.k_)(t),{blob:o,assetName:s.assetName,assetType:a}}(e,s))),t,s)}async function A(e,t,s){const a=await Promise.all(e.map((async e=>{const a=async function I(e,o,i){const{blob:u,assetType:l,assetName:c}=e;let p=null;try{const e=await uploads_p({data:u,name:c},o.url,i);(0,promiseUtils.k_)(i),p={assetType:l,assetUploadId:e.itemID}}catch(f){(0,promiseUtils.r9)(f),Logger.Z.getLogger("esri.layers.graphics.sources.support.uploadAssets").warnOnce(`Service ${o.url} does not support the REST Uploads API.`)}if(!p){const e=await(0,urlUtils.IR)(u);if((0,promiseUtils.k_)(i),!e.isBase64)throw new core_Error.Z(`${o.type}-layer:uploadAssets-failure`,"Expected gltf data in base64 format after conversion.",new Error);p={assetType:l,assetData:e.data}}if(!p)throw new core_Error.Z(`${o.type}-layer:uploadAssets-failure`,"Unable to prepare uploadAsset request options.",new Error);return{item:p,assetName:c}}(await e,t,s);return(0,promiseUtils.k_)(s),a})));(0,promiseUtils.k_)(s);const{uploadResults:o}=await async function R(s,a,o){const n=await(0,request.default)((0,urlUtils.v_)(a.parsedUrl.path,"uploadAssets"),{timeout:0,query:{f:"json",assets:JSON.stringify(s)},method:"post",responseType:"json"});if((0,promiseUtils.k_)(o),n.data.uploadResults.length!==s.length)throw new core_Error.Z(`${a.type}-layer:uploadAssets-failure`,`Bad response. Uploaded ${s.length} items and received ${n.data.uploadResults.length} results.`,new Error);return n.data}(a.map((({item:e})=>e)),t,s);return(0,promiseUtils.k_)(s),e.map(((e,s)=>function L(e,s,r){const{success:a}=s;if(!a){const{error:a}=s;throw new core_Error.Z(`${r.type}-layer:upload-failure`,`Failed to upload mesh file ${e.assetName}. Error code: ${a.code}. Error message: ${a.messages}`,new Error)}const{assetHash:o}=s,{assetName:n,item:{assetType:i}}=e,{infoFor3D:{supportedFormats:u}}=r,l=(0,infoFor3D.d1)(i,u);if(!l)throw new core_Error.Z(`${r.type}-layer:upload-failure`,`The service allowed us to upload an asset of FormatID ${i}, but it does not list it in its supported formats.`,new Error);return new External.CP(n,l,[new External.LL(`${r.parsedUrl.path}/assets/${o}`,o)])}(a[s],o[s],t)))}async function q(s,r,a){const o=s.map((({assetName:e,parts:t})=>({assetName:e,assetHash:t[0].partHash}))),n=r.capabilities?.operations.supportsAsyncConvert3D,u={query:{f:"json",assets:JSON.stringify(o),transportType:"esriTransportTypeUrl",targetFormat:a,async:n},responseType:"json",timeout:0},l=(0,urlUtils.v_)(r.parsedUrl.path,"convert3D"),c=(n?await async function C(s,r){const a=(await(0,request.default)(s,r)).data.statusUrl;for(;;){const s=(await(0,request.default)(a,{query:{f:"json"},responseType:"json"})).data;switch(s.status){case"Completed":return(0,request.default)(s.resultUrl,{query:{f:"json"},responseType:"json"});case"CompletedWithErrors":throw new core_Error.Z("async-convert3D-failed","asynchronous convert3D call failed.");case"Failed ImportChanges":case"InProgress":case"Pending":case"ExportAttachments":case"ExportChanges":case"ExportingData":case"ExportingSnapshot":case"ImportAttachments":case"ProvisioningReplica":case"UnRegisteringReplica":break;default:throw new core_Error.Z("async-convert3D-failed","asynchronous convert3D call failed (undefined response status)")}await(0,promiseUtils.e4)(H)}}(l,u):await(0,request.default)(l,u)).data,{infoFor3D:{supportedFormats:d}}=r;return c.assets.map((e=>{const s=(0,infoFor3D.S0)(e.contentType,d);if(!s)throw new core_Error.Z(`${r.type}-layer:upload-failure`,`The service allowed us to upload an asset of FormatID ${s}, but it does not list it in its supported formats.`,new Error);return new External.CP(e.assetName,e.contentType,[new External.LL(e.assetURL,e.assetHash)])}))}function B(e){const{infoFor3D:s}=e,r=(0,infoFor3D.S0)("model/gltf-binary",s.supportedFormats)??(0,infoFor3D.Ow)("glb",s.supportedFormats);if(!r)throw new core_Error.Z(`${e.type}-layer:upload-failure`,"Layer does not support glb.",new Error);return r}const H=1e3}}]);