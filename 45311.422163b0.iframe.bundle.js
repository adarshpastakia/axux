"use strict";(self.webpackChunkaxux=self.webpackChunkaxux||[]).push([[45311],{"./node_modules/@arcgis/core/layers/ImageryTileLayer.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.r(__webpack_exports__),__webpack_require__.d(__webpack_exports__,{default:()=>A});var tslib_es6=__webpack_require__("./node_modules/@arcgis/core/chunks/tslib.es6.js"),PopupTemplate=__webpack_require__("./node_modules/@arcgis/core/PopupTemplate.js"),Clonable=__webpack_require__("./node_modules/@arcgis/core/core/Clonable.js"),core_Error=__webpack_require__("./node_modules/@arcgis/core/core/Error.js"),Logger=__webpack_require__("./node_modules/@arcgis/core/core/Logger.js"),MultiOriginJSONSupport=__webpack_require__("./node_modules/@arcgis/core/core/MultiOriginJSONSupport.js"),promiseUtils=__webpack_require__("./node_modules/@arcgis/core/core/promiseUtils.js"),reactiveUtils=__webpack_require__("./node_modules/@arcgis/core/core/reactiveUtils.js"),property=__webpack_require__("./node_modules/@arcgis/core/core/accessorSupport/decorators/property.js"),ensureType=__webpack_require__("./node_modules/@arcgis/core/core/accessorSupport/ensureType.js"),arrayUtils=__webpack_require__("./node_modules/@arcgis/core/core/arrayUtils.js"),has=__webpack_require__("./node_modules/@arcgis/core/core/has.js"),enumeration=__webpack_require__("./node_modules/@arcgis/core/core/accessorSupport/decorators/enumeration.js"),subclass=__webpack_require__("./node_modules/@arcgis/core/core/accessorSupport/decorators/subclass.js"),Layer=__webpack_require__("./node_modules/@arcgis/core/layers/Layer.js"),ArcGISService=__webpack_require__("./node_modules/@arcgis/core/layers/mixins/ArcGISService.js"),BlendLayer=__webpack_require__("./node_modules/@arcgis/core/layers/mixins/BlendLayer.js"),CustomParametersMixin=__webpack_require__("./node_modules/@arcgis/core/layers/mixins/CustomParametersMixin.js"),rasterRenderers=(__webpack_require__("./node_modules/@arcgis/core/geometry.js"),__webpack_require__("./node_modules/@arcgis/core/rasterRenderers.js")),request=__webpack_require__("./node_modules/@arcgis/core/request.js"),reader=__webpack_require__("./node_modules/@arcgis/core/core/accessorSupport/decorators/reader.js"),spatialReferenceUtils=__webpack_require__("./node_modules/@arcgis/core/geometry/support/spatialReferenceUtils.js"),arcgisLayerUrl=__webpack_require__("./node_modules/@arcgis/core/layers/support/arcgisLayerUrl.js"),commonProperties=__webpack_require__("./node_modules/@arcgis/core/layers/support/commonProperties.js"),DimensionalDefinition=__webpack_require__("./node_modules/@arcgis/core/layers/support/DimensionalDefinition.js"),MultidimensionalSubset=__webpack_require__("./node_modules/@arcgis/core/layers/support/MultidimensionalSubset.js"),RasterFunction=__webpack_require__("./node_modules/@arcgis/core/layers/support/RasterFunction.js"),RasterJobHandler=__webpack_require__("./node_modules/@arcgis/core/layers/support/RasterJobHandler.js"),TileInfo=__webpack_require__("./node_modules/@arcgis/core/layers/support/TileInfo.js"),JSONSupport=__webpack_require__("./node_modules/@arcgis/core/core/JSONSupport.js"),core_Promise=__webpack_require__("./node_modules/@arcgis/core/core/Promise.js"),LOD=__webpack_require__("./node_modules/@arcgis/core/layers/support/LOD.js"),RasterStorageInfo=__webpack_require__("./node_modules/@arcgis/core/layers/support/RasterStorageInfo.js"),multidimensionalUtils=__webpack_require__("./node_modules/@arcgis/core/layers/support/rasterDatasets/multidimensionalUtils.js"),RawBlockCache=__webpack_require__("./node_modules/@arcgis/core/layers/support/rasterDatasets/RawBlockCache.js"),pixelRangeUtils=__webpack_require__("./node_modules/@arcgis/core/layers/support/rasterFormats/pixelRangeUtils.js"),RasterCodec=__webpack_require__("./node_modules/@arcgis/core/layers/support/rasterFormats/RasterCodec.js"),pixelUtils=__webpack_require__("./node_modules/@arcgis/core/layers/support/rasterFunctions/pixelUtils.js"),rasterProjectionHelper=__webpack_require__("./node_modules/@arcgis/core/layers/support/rasterFunctions/rasterProjectionHelper.js"),vectorFieldUtils=__webpack_require__("./node_modules/@arcgis/core/layers/support/rasterFunctions/vectorFieldUtils.js"),Extent=__webpack_require__("./node_modules/@arcgis/core/geometry/Extent.js"),Point=__webpack_require__("./node_modules/@arcgis/core/geometry/Point.js");let V=class extends((0,core_Promise.g)(JSONSupport.oY)){constructor(){super(...arguments),this.datasetName=null,this.datasetFormat=null,this.hasUniqueSourceStorageInfo=!0,this.rasterInfo=null,this.ioConfig={sampling:"closest"}}async init(){const e=(0,rasterProjectionHelper.Hh)();this.addResolvingPromise(e),await this.when()}normalizeCtorArgs(e){return e?.ioConfig&&(e={...e,ioConfig:{resolution:null,bandIds:null,sampling:"closest",tileInfo:TileInfo.A.create(),...e.ioConfig}}),e}get _isGlobalWrappableSource(){const{rasterInfo:e}=this,t=(0,rasterProjectionHelper.FT)(e.spatialReference);return null!=t&&e.extent.width>=t/2}get _hasNoneOrGCSShiftTransform(){const{transform:e}=this.rasterInfo;return null==e||"gcs-shift"===e.type}set rasterJobHandler(e){this._set("rasterJobHandler",e),"Function"===this.datasetFormat&&this.primaryRasters?.rasters?.forEach((t=>t.rasterJobHandler=e))}set url(e){this._set("url",(0,arcgisLayerUrl.Jf)(e,Logger.A.getLogger(this)))}async open(e){throw new core_Error.A("BaseRaster:open-not-implemented","open() is not implemented")}async fetchTile(e,t,i,o={}){const r=o.tileInfo||this.rasterInfo.storageInfo.tileInfo,n=this.getTileExtentFromTileInfo(e,t,i,r);return this.fetchPixels(n,r.size[0],r.size[1],o)}async identify(e,t={}){e=(0,ensureType.PZ)(Point.A,e).clone().normalize();const{multidimensionalDefinition:i,timeExtent:o}=t,{rasterInfo:r}=this,{hasMultidimensionalTranspose:n,multidimensionalInfo:s}=r;let{transposedVariableName:l}=t;const c=null!=s&&n&&(null!=o||(0,multidimensionalUtils.DY)(i));c&&!l&&(l=null!=i&&i.length>0?i[0].variableName??void 0:s.variables[0].name,t={...t,transposedVariableName:l}),t=this._getRequestOptionsWithSliceId(t);const{spatialReference:m,extent:f}=r,{datumTransformation:u}=t;let h=(0,rasterProjectionHelper._I)(e,m,u);if(!f.intersects(h))return{location:h,value:null};if(null!=r.transform){const e=r.transform.inverseTransform(h);if(!r.nativeExtent.intersects(e))return{location:e,value:null};h=e}let p=0;const d=null!=l&&null!=s&&r.hasMultidimensionalTranspose;if("Function"===this.datasetFormat){const e=this.primaryRasters.rasters[0];if(d)return e.identify(h,t);const{pixelSize:i}=r,o=3,n=i.x*o/2,s=i.y*o/2,l=new Extent.A({xmin:h.x-n,xmax:h.x+n,ymin:h.y-s,ymax:h.y+s,spatialReference:m}),a={interpolation:"nearest"},{pixelBlock:c}=await e.fetchPixels(l,o,o,a),{pixelBlock:f}=await this.fetchPixels(l,o,o,a);if(null==c)return{location:h,value:null};const u=Math.floor(o*o*.5),p=!c.mask||c.mask[u]?c.pixels.map((e=>e[u])):null;let x;return null!=f&&(x=!f.mask||f.mask[u]?f.pixels.map((e=>e[u])):void 0),{location:h,value:p,processedValue:x,pyramidLevel:0}}if(!d)if(t.srcResolution)p=(0,rasterProjectionHelper.t$)(t.srcResolution,r,this.ioConfig.sampling).pyramidLevel;else if(p=await this.computeBestPyramidLevelForLocation(e,t),null==p)return{location:h,value:null};const y=this.identifyPixelLocation(h,p,null,d);if(null===y)return{location:h,value:null};const{row:g,col:I,rowOffset:k,colOffset:T,blockWidth:b}=y,v=l??t.sliceId,P=(0,RawBlockCache.ph)(this.url,v),B=`${p}/${g}/${I}`;let M=(0,RawBlockCache.gd)(P,null,B);null==M&&(M=this.fetchRawTile(p,g,I,t),(0,RawBlockCache.no)(P,null,B,M));const _=await M;if(!_?.pixels?.length)return{location:h,value:null};const W=k*b+T;return this._processIdentifyResult(_,{srcLocation:h,position:W,pyramidLevel:p,useTransposedTile:!!d,requestSomeSlices:c,identifyOptions:t})}async fetchPixels(e,t,i,o={}){e=(0,rasterProjectionHelper.Ps)(e),o=this._getRequestOptionsWithSliceId(o);const{_hasNoneOrGCSShiftTransform:r}=this;if(o.requestRawData&&r)return this._fetchPixels(e,t,i,o);const n=(0,rasterProjectionHelper.FT)(e.spatialReference),s=(0,rasterProjectionHelper.OM)(e);if(null==n||0===s||1===s&&this._isGlobalWrappableSource&&r)return this._fetchPixels(e,t,i,o);if(s>=3)return{extent:e,pixelBlock:null};const l=[],{xmin:a,xmax:c}=e,m=Math.round(n/(c-a)*t),f=m-Math.round((n/2-a)/(c-a)*t);let u=0;const h=[];for(let y=0;y<=s;y++){const r=new Extent.A({xmin:0===y?a:-n/2,xmax:y===s?c-n*y:n/2,ymin:e.ymin,ymax:e.ymax,spatialReference:e.spatialReference}),p=0===y?m-f:y===s?t-u:m;u+=p,h.push(p);const d=o.disableWrapAround&&y>0?null:this._fetchPixels(r,p,i,o);l.push(d)}const p=(await Promise.all(l)).map((e=>e?.pixelBlock));let d=null;const x={width:t,height:i};return d=this.rasterJobHandler?(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:p,srcMosaicSize:x,destDimension:null,coefs:null,sampleSpacing:null,interpolation:"nearest",alignmentInfo:null,blockWidths:h},o)).pixelBlock:(0,pixelUtils.z7)(p,x,{blockWidths:h}),{extent:e,srcExtent:(0,rasterProjectionHelper._l)(e,this.rasterInfo.spatialReference,o.datumTransformation),pixelBlock:d}}async fetchRawPixels(e,t,i,o={}){t={x:Math.floor(t.x),y:Math.floor(t.y)};const r=await this._fetchRawTiles(e,t,i,o),{nativeExtent:n,nativePixelSize:s,storageInfo:l}=this.rasterInfo,a=2**e,c=s.x*a,m=s.y*a,f=new Extent.A({xmin:n.xmin+c*t.x,xmax:n.xmin+c*(t.x+i.width-1),ymin:n.ymax-m*(t.y+i.height-1),ymax:n.ymax-m*t.y,spatialReference:n.spatialReference});if(!r)return{extent:f,srcExtent:f,pixelBlock:null};const{pixelBlocks:u,mosaicSize:h}=r;if(1===u.length&&null!=u[0]&&u[0].width===i.width&&u[0].height===i.height)return{extent:f,srcExtent:f,pixelBlock:r.pixelBlocks[0]};const p=e>0?l.pyramidBlockWidth:l.blockWidth,d=e>0?l.pyramidBlockHeight:l.blockHeight,x={x:t.x%p,y:t.y%d};let y;return y=this.rasterJobHandler?(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:u,srcMosaicSize:h,destDimension:i,clipOffset:x,clipSize:i,coefs:null,sampleSpacing:null,interpolation:o.interpolation,alignmentInfo:null,blockWidths:null},o)).pixelBlock:(0,pixelUtils.z7)(u,h,{clipOffset:x,clipSize:i}),{extent:f,srcExtent:f,pixelBlock:y}}fetchRawTile(e,t,o,r){throw new core_Error.A("BaseRaster:read-not-implemented","fetchRawTile() is not implemented")}computeExtent(e){return(0,rasterProjectionHelper._l)(this.rasterInfo.extent,e)}decodePixelBlock(e,t){return!this.rasterJobHandler||t.useCanvas?(0,RasterCodec.D)(e,t):this.rasterJobHandler.decode({data:e,options:t})}async request(e,i,o=0){const{customFetchParameters:r}=this.ioConfig,{range:n,query:s,headers:l}=i;o=o??i.retryCount??this.ioConfig.retryCount;const a=n?{Range:`bytes=${n.from}-${n.to}`}:null;try{return await(0,request.A)(e,{...i,query:{...s,...r},headers:{...l,...a}})}catch(c){if(o>0)return o--,this.request(e,i,o);throw c}}getSliceIndex(e){const{multidimensionalInfo:t}=this.rasterInfo;return null==t||null==e||0===e.length?null:(0,multidimensionalUtils.NG)(e,t)}getTileExtentFromTileInfo(e,t,i,o){const r=o.lodAt(e);return this.getTileExtent({x:r.resolution,y:r.resolution},t,i,o.origin,o.spatialReference,o.size)}updateTileInfo(){const{storageInfo:e,spatialReference:t,extent:i,pixelSize:o}=this.rasterInfo;if(!e.tileInfo){const r=[],n=e.maximumPyramidLevel||0;let s=Math.max(o.x,o.y),l=1/.0254*96*s;for(let e=0;e<=n;e++)r.unshift(new LOD.A({level:n-e,resolution:s,scale:l})),s*=2,l*=2;const a=new Point.A({x:i.xmin,y:i.ymax,spatialReference:t});e.tileInfo=new TileInfo.A({origin:a,size:[e.blockWidth,e.blockHeight],spatialReference:t,lods:r}),e.isVirtualTileInfo=!0}}createRemoteDatasetStorageInfo(e,t=512,i=512,o){const{width:r,height:n,nativeExtent:s,pixelSize:l,spatialReference:a}=e,c=new Point.A({x:s.xmin,y:s.ymax,spatialReference:a});null==o&&(o=Math.max(0,Math.round(Math.log(Math.max(r,n))/Math.LN2-8)));const m=this.computeBlockBoundary(s,512,512,{x:s.xmin,y:s.ymax},[l],o);e.storageInfo=new RasterStorageInfo.A({blockWidth:t,blockHeight:i,pyramidBlockWidth:t,pyramidBlockHeight:i,origin:c,firstPyramidLevel:1,maximumPyramidLevel:o,blockBoundary:m})}async computeBestPyramidLevelForLocation(e,t={}){return 0}computeBlockBoundary(e,t,i,o,r,n=0,s=2){if(1===r.length&&n>0){r=[...r];let{x:e,y:t}=r[0];for(let i=0;i<n;i++)e*=s,t*=s,r.push({x:e,y:t})}const l=[],{x:a,y:c}=o;for(let m=0;m<r.length;m++){const{x:o,y:n}=r[m];l.push({minCol:Math.floor((e.xmin-a+.1*o)/t/o),maxCol:Math.floor((e.xmax-a-.1*o)/t/o),minRow:Math.floor((c-e.ymax+.1*n)/i/n),maxRow:Math.floor((c-e.ymin-.1*n)/i/n)})}return l}getPyramidPixelSize(e){const{nativePixelSize:t}=this.rasterInfo,{pyramidResolutions:i,pyramidScalingFactor:o}=this.rasterInfo.storageInfo;if(0===e)return t;if(null!=i&&i.length)return i[e-1];const r=o**e;return{x:t.x*r,y:t.y*r}}identifyPixelLocation(e,t,i,o){const{spatialReference:r,nativeExtent:n,storageInfo:s}=this.rasterInfo,{maximumPyramidLevel:l,origin:a,transposeInfo:c}=s,m=o&&null!=c?c.tileSize[0]:s.blockWidth,f=o&&null!=c?c.tileSize[1]:s.blockHeight,u=(0,rasterProjectionHelper._I)(e,r,i);if(!n.intersects(u))return null;if(t<0||t>l)return null;const h=this.getPyramidPixelSize(t),{x:p,y:d}=h,x=(a.y-u.y)/d/f,y=(u.x-a.x)/p/m,g=Math.min(f-1,Math.floor((x-Math.floor(x))*f)),I=Math.min(m-1,Math.floor((y-Math.floor(y))*m));return{pyramidLevel:t,row:Math.floor(x),col:Math.floor(y),rowOffset:g,colOffset:I,blockWidth:m,srcLocation:u}}getTileExtent(e,t,i,o,r,n){const[s,l]=n,a=o.x+i*s*e.x,c=a+s*e.x,m=o.y-t*l*e.y,f=m-l*e.y;return new Extent.A({xmin:a,xmax:c,ymin:f,ymax:m,spatialReference:r})}getBlockWidthHeight(e){return{blockWidth:e>0?this.rasterInfo.storageInfo.pyramidBlockWidth:this.rasterInfo.storageInfo.blockWidth,blockHeight:e>0?this.rasterInfo.storageInfo.pyramidBlockHeight:this.rasterInfo.storageInfo.blockHeight}}isBlockOutside(e,t,i){const o=this.rasterInfo.storageInfo.blockBoundary[e];return!o||o.maxRow<t||o.maxCol<i||o.minRow>t||o.minCol>i}async _fetchPixels(e,t,i,o={}){let r=(0,rasterProjectionHelper.OM)(e);if(r>=2)return{extent:e,pixelBlock:null};const n=this._getSourceDataInfo(e,t,i,o),{pyramidLevel:s,srcResolution:l,srcExtent:a,srcWidth:c,srcHeight:m,ul:f}=n;if(0===c||0===m)return{extent:e,srcExtent:a,pixelBlock:null};const{rasterInfo:u}=this,h=u.transform,p="gcs-shift"===h?.type,d=null!=(0,rasterProjectionHelper.FT)(e.spatialReference);!p&&d||(r=(0,rasterProjectionHelper.OM)(n.srcExtent,p));const x=await this._fetchRawTiles(s,f,{width:c,height:m,wrapCount:r},o);if(!x)return{extent:e,srcExtent:a,pixelBlock:null};const y=u.storageInfo,g=s>0?y.pyramidBlockWidth:y.blockWidth,I=s>0?y.pyramidBlockHeight:y.blockHeight;let{x:R,y:w}=u.pixelSize;if(s>0){const{pyramidResolutions:e,pyramidScalingFactor:t}=y;if(null!=e&&e[s-1])({x:R,y:w}=e[s-1]);else{const e=t**s;R*=e,w*=e}}const S=u.spatialReference,k=new Point.A({x:R,y:w,spatialReference:S}),T=g===c&&I===m&&f.x%g==0&&f.y%I==0,b=new Point.A({x:(e.xmax-e.xmin)/t,y:(e.ymax-e.ymin)/i,spatialReference:e.spatialReference}),v=!e.spatialReference.equals(S),C=S.isGeographic?1e-9:1e-4,{datumTransformation:j}=o;if(!v&&T&&1===x.pixelBlocks.length&&g===t&&I===i&&this._isSameResolution(l,b,C))return{extent:e,srcExtent:a,srcTilePixelSize:k,pixelBlock:x.pixelBlocks[0]};const H=d&&null!=(0,rasterProjectionHelper.FT)(a.spatialReference)&&this._hasNoneOrGCSShiftTransform,L=o.requestProjectedLocalDirections&&this.rasterInfo.dataType.startsWith("vector");L&&!this.rasterJobHandler&&await(0,rasterProjectionHelper.Hh)();const D=this.rasterJobHandler?await this.rasterJobHandler.getProjectionOffsetGrid({projectedExtent:e,srcBufferExtent:x.extent,pixelSize:b.toJSON(),datumTransformation:j,rasterTransform:h,hasWrapAround:r>0||H,isAdaptive:!1!==this.ioConfig.optimizeProjectionAccuracy,includeGCSGrid:L},o):(0,rasterProjectionHelper.l0)({projectedExtent:e,srcBufferExtent:x.extent,pixelSize:b,datumTransformation:j,rasterTransform:h,hasWrapAround:r>0||H,isAdaptive:!1,includeGCSGrid:L});let F;const A=!o.requestRawData,G={rows:D.spacing[0],cols:D.spacing[1]},J=this._hasNoneOrGCSShiftTransform?this._getRasterTileAlignmentInfo(s,x.extent.xmin):void 0,{pixelBlocks:N,mosaicSize:V,isPartiallyFilled:U}=x;let $=null;if(this.rasterJobHandler){const e=await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:N,srcMosaicSize:V,destDimension:A?{width:t,height:i}:null,coefs:A?D.coefficients:null,sampleSpacing:A?G:null,projectDirections:L,gcsGrid:L?D.gcsGrid:null,isUV:"vector-uv"===this.rasterInfo.dataType,interpolation:o.interpolation,alignmentInfo:J,blockWidths:null},o);({pixelBlock:F,localNorthDirections:$}=e)}else{const e=(0,pixelUtils.z7)(N,V,{alignmentInfo:J});F=A?(0,pixelUtils.$i)(e,{width:t,height:i},D.coefficients,G,o.interpolation):e,L&&D.gcsGrid&&($=(0,pixelUtils.QF)({width:t,height:i},D.gcsGrid),F=(0,vectorFieldUtils.Y2)(F,this.rasterInfo.dataType,$))}return o.requestRawData||L?{extent:e,srcExtent:a,srcTilePixelSize:k,pixelBlock:F,transformGrid:D,localNorthDirections:$,isPartiallyFilled:U}:{extent:e,srcExtent:a,srcTilePixelSize:k,pixelBlock:F}}async _fetchRawTiles(e,t,i,o){const{origin:r,blockBoundary:n}=this.rasterInfo.storageInfo,{blockWidth:s,blockHeight:l}=this.getBlockWidthHeight(e);let{x:a,y:c}=t,{width:m,height:f,wrapCount:u}=i;const h=this._getRasterTileAlignmentInfo(e,0);o.buffer&&(a-=o.buffer.cols,c-=o.buffer.rows,m+=2*o.buffer.cols,f+=2*o.buffer.rows);let p=0,d=0,x=0;u&&null!=h&&(({worldColumnCountFromOrigin:d,originColumnOffset:x,rightPadding:p}=h),d*h.blockWidth-p>=a+m&&(p=0));const y=Math.floor(a/s),g=Math.floor(c/l),I=Math.floor((a+m+p-1)/s),R=Math.floor((c+f+p-1)/l),w=n[e];if(!w)return null;const{minRow:S,minCol:k,maxCol:T,maxRow:b}=w;if(0===u&&(R<S||I<k||g>b||y>T))return null;const v=new Array;let P=!1;const B=null==this.ioConfig.allowPartialFill?o.allowPartialFill:this.ioConfig.allowPartialFill;for(let z=g;z<=R;z++)for(let t=y;t<=I;t++){let i=t;if(!o.disableWrapAround&&u&&null!=h&&d<=t&&(i=t-d-x),z>=S&&i>=k&&b>=z&&T>=i){const t=this._fetchRawTile(e,z,i,o);B?v.push(new Promise((e=>{t.then((t=>e(t))).catch((()=>{P=!0,e(null)}))}))):v.push(t)}else v.push(Promise.resolve(null))}if(0===v.length)return null;const M=await Promise.all(v),_={height:(R-g+1)*l,width:(I-y+1)*s},{spatialReference:W}=this.rasterInfo,C=this.getPyramidPixelSize(e),{x:j,y:H}=C;return{extent:new Extent.A({xmin:r.x+y*s*j,xmax:r.x+(I+1)*s*j,ymin:r.y-(R+1)*l*H,ymax:r.y-g*l*H,spatialReference:W}),pixelBlocks:M,mosaicSize:_,isPartiallyFilled:P}}_isSameResolution(e,t,i){return Math.abs(e.x-t.x)<i&&Math.abs(e.y-t.y)<i}_fetchRawTile(e,t,i,o){const r=this.rasterInfo.storageInfo.blockBoundary[e];if(!r)return Promise.resolve(null);const{minRow:n,minCol:l,maxCol:a,maxRow:c}=r;if(t<n||i<l||t>c||i>a)return Promise.resolve(null);const m=(0,RawBlockCache.ph)(this.url,o.sliceId),f=`${e}/${t}/${i}`;let u=(0,RawBlockCache.gd)(m,o.registryId,f);if(null==u){const r=new AbortController;u=this.fetchRawTile(e,t,i,{...o,signal:r.signal}),(0,RawBlockCache.no)(m,o.registryId,f,u,r),u.catch((()=>(0,RawBlockCache.zo)(m,o.registryId,f)))}return o.signal&&(0,promiseUtils.u7)(o,(()=>{(0,RawBlockCache.jX)(m,o.registryId,f)})),u}_computeMagDirValues(e){const{bandCount:t,dataType:i}=this.rasterInfo;if((2!==t||"vector-magdir"!==i)&&"vector-uv"!==i||2!==e?.length||!e[0]?.length)return null;const o=e[0].length;if("vector-magdir"===i){const t=e[1].map((e=>(e+360)%360));return[e[0],t]}const[r,n]=e,s=[],l=[];for(let a=0;a<o;a++){const[e,t]=(0,vectorFieldUtils.Lu)([r[a],n[a]]);s.push(e),l.push(t)}return[s,l]}_getRasterTileAlignmentInfo(e,t){return null==this._rasterTileAlighmentInfo&&(this._rasterTileAlighmentInfo=(0,rasterProjectionHelper.DO)(this.rasterInfo)),null==this._rasterTileAlighmentInfo.pyramidsInfo?null:{startX:t,halfWorldWidth:this._rasterTileAlighmentInfo.halfWorldWidth,hasGCSSShiftTransform:this._rasterTileAlighmentInfo.hasGCSSShiftTransform,...this._rasterTileAlighmentInfo.pyramidsInfo[e]}}_getSourceDataInfo(e,t,i,o={}){const r={datumTransformation:o.datumTransformation,pyramidLevel:0,pyramidResolution:null,srcExtent:null,srcHeight:0,srcResolution:null,srcWidth:0,ul:{x:0,y:0}};o.srcResolution&&(r.srcResolution=o.srcResolution,this._updateSourceDataInfo(e,r));const n=this.rasterInfo.storageInfo.maximumPyramidLevel||0,{srcWidth:s,srcHeight:l,pyramidLevel:a}=r,c=s/t,m=l/i,f=a<n&&c*m>=16,u=a===n&&this._requireTooManySrcTiles(s,l,t,i);if(f||u||0===s||0===l){const s=new Point.A({x:(e.xmax-e.xmin)/t,y:(e.ymax-e.ymin)/i,spatialReference:e.spatialReference});let l=(0,rasterProjectionHelper.Wo)(s,this.rasterInfo.spatialReference,e,r.datumTransformation);const u=!l||o.srcResolution&&l.x+l.y<o.srcResolution.x+o.srcResolution.y;if(f&&o.srcResolution&&u){const e=Math.round(Math.log(Math.max(c,m))/Math.LN2)-1;if(n-a+3>=e){const t=2**e;l={x:o.srcResolution.x*t,y:o.srcResolution.y*t}}}l&&(r.srcResolution=l,this._updateSourceDataInfo(e,r))}return this._requireTooManySrcTiles(r.srcWidth,r.srcHeight,t,i)&&(r.srcWidth=0,r.srcHeight=0),r}_requireTooManySrcTiles(e,t,i,o){const{tileInfo:r}=this.rasterInfo.storageInfo;return Math.ceil(e/r.size[0])*Math.ceil(t/r.size[1])>=256||e/i>8||t/o>8}_updateSourceDataInfo(e,t){t.srcWidth=0,t.srcHeight=0;const{rasterInfo:i}=this,o=i.spatialReference,{srcResolution:r,datumTransformation:n}=t,{pyramidLevel:s,pyramidResolution:l,excessiveReading:a}=(0,rasterProjectionHelper.t$)(r,i,this.ioConfig.sampling);if(a)return;let c=t.srcExtent||(0,rasterProjectionHelper._l)(e,o,n);if(null==c)return;const m=i.transform;m&&(c=m.inverseTransform(c)),t.srcExtent=c;const{x:f,y:u}=i.storageInfo.origin,h=Math.floor((c.xmin-f)/l.x+.1),p=Math.floor((u-c.ymax)/l.y+.1),d=Math.floor((c.xmax-f)/l.x-.1),x=Math.floor((u-c.ymin)/l.y-.1),y=c.width<.1*l.x?0:d-h+1,g=c.height<.1*l.y?0:x-p+1;t.pyramidLevel=s,t.pyramidResolution=l,t.srcWidth=y,t.srcHeight=g,t.ul={x:h,y:p}}_getRequestOptionsWithSliceId(e){return null!=this.rasterInfo.multidimensionalInfo&&null==e.sliceId&&(e={...e,sliceId:this.getSliceIndex(e.multidimensionalDefinition)}),e}_processIdentifyResult(e,t){const{srcLocation:i,position:o,pyramidLevel:r,useTransposedTile:n}=t,s=e.pixels[0].length/e.width/e.height;if(e.mask&&!e.mask[o])return{location:i,value:null};const{multidimensionalInfo:l}=this.rasterInfo;if(null==l||!n){const t=e.pixels.map((e=>e[o])),n={location:i,value:t,pyramidLevel:r},s=this._computeMagDirValues(t.map((e=>[e])));return s?.length&&(n.magdirValue=s.map((e=>e[0]))),n}let a=e.pixels.map((e=>e.slice(o*s,o*s+s))),c=this._computeMagDirValues(a);const{requestSomeSlices:m,identifyOptions:f}=t;let h=(0,multidimensionalUtils.QW)(l,f.transposedVariableName);if(m){const e=(0,multidimensionalUtils.xx)(h,f.multidimensionalDefinition,f.timeExtent);a=a.map((t=>e.map((e=>t[e])))),c=c?.map((t=>e.map((e=>t[e])))),h=e.map((e=>h[e]))}const p=e.noDataValues||this.rasterInfo.noDataValue,d={pixels:a,pixelType:e.pixelType};let x;return null!=p&&((0,pixelRangeUtils.S)(d,p),x=d.mask),{location:i,value:null,dataSeries:h.map(((e,t)=>{const i={value:0===x?.[t]?null:a.map((e=>e[t])),multidimensionalDefinition:e.multidimensionalDefinition.map((e=>new DimensionalDefinition.A({...e,isSlice:!0})))};return c?.length&&(i.magdirValue=[c[0][t],c[1][t]]),i})),pyramidLevel:r}}};(0,tslib_es6._)([(0,property.MZ)()],V.prototype,"_rasterTileAlighmentInfo",void 0),(0,tslib_es6._)([(0,property.MZ)({readOnly:!0})],V.prototype,"_isGlobalWrappableSource",null),(0,tslib_es6._)([(0,property.MZ)({readOnly:!0})],V.prototype,"_hasNoneOrGCSShiftTransform",null),(0,tslib_es6._)([(0,property.MZ)()],V.prototype,"rasterJobHandler",null),(0,tslib_es6._)([(0,property.MZ)(commonProperties.OZ)],V.prototype,"url",null),(0,tslib_es6._)([(0,property.MZ)({type:String,json:{write:!0}})],V.prototype,"datasetName",void 0),(0,tslib_es6._)([(0,property.MZ)({type:String,json:{write:!0}})],V.prototype,"datasetFormat",void 0),(0,tslib_es6._)([(0,property.MZ)()],V.prototype,"hasUniqueSourceStorageInfo",void 0),(0,tslib_es6._)([(0,property.MZ)()],V.prototype,"rasterInfo",void 0),(0,tslib_es6._)([(0,property.MZ)()],V.prototype,"ioConfig",void 0),(0,tslib_es6._)([(0,property.MZ)()],V.prototype,"sourceJSON",void 0),V=(0,tslib_es6._)([(0,subclass.$)("esri.layers.support.rasterDatasets.BaseRaster")],V);const U=V;var FeatureSet=__webpack_require__("./node_modules/@arcgis/core/rest/support/FeatureSet.js");let n=class extends U{constructor(){super(...arguments),this.datasetFormat="Function",this.tileType="Raster",this.rasterFunction=null}async open(t){await this.init();const{rasterFunction:r}=this;this.primaryRasters?.rasters?.length?r.sourceRasters=this.primaryRasters.rasters:(this.primaryRasters=r.getPrimaryRasters(),this.rasterJobHandler&&this.primaryRasters.rasters?.forEach((t=>t.rasterJobHandler=this.rasterJobHandler)));const{rasters:s,rasterIds:a}=this.primaryRasters,i=s.map((e=>e.rasterInfo?void 0:e.open(t)));await Promise.all(i);const n=s.map((({rasterInfo:t})=>t)),c=r.bind({rasterInfos:n,rasterIds:a});if(!c.success||0===n.length)throw new core_Error.A("raster-function:open",`cannot bind the function: ${c.error??""}`);const l="Table"===r.functionName?r:r.functionArguments?.raster;"Table"===l?.functionName&&(r.rasterInfo.attributeTable=FeatureSet.A.fromJSON(l.functionArguments.attributeTableAsRecordSet)),await this.syncJobHandler();const p=n[0];this.hasUniqueSourceStorageInfo=1===n.length||n.slice(1).every((t=>this._hasSameStorageInfo(t,p))),this.set("sourceJSON",s[0].sourceJSON),this.set("rasterInfo",r.rasterInfo)}async syncJobHandler(){return this.rasterJobHandler?.updateRasterFunction(this.rasterFunction)}async fetchPixels(t,e,r,s={}){const{rasters:a,rasterIds:o}=this.primaryRasters;let n=!1;const{interpolation:c}=s,l=this.rasterFunction.flatWebGLFunctionChain?.hasFocalFunction;!s.requestRawData&&"bilinear"!==c&&l&&(n=1===a.length&&!s.skipRasterFunction,s={...s,interpolation:"bilinear",requestRawData:n});const p=a.map((a=>a.fetchPixels(t,e,r,s))),u=await Promise.all(p),m=u.map((t=>t.pixelBlock)),h=n||s.requestRawData?u.map((t=>t.srcTilePixelSize)):null;if(s.skipRasterFunction||m.every((t=>null==t)))return u[0];const d=u.find((t=>null!=t.pixelBlock))?.extent??t,f=this.rasterJobHandler?await this.rasterJobHandler.process({extent:d,primaryPixelBlocks:m,primaryPixelSizes:h,primaryRasterIds:o}):this.rasterFunction.process({extent:d,primaryPixelBlocks:m,primaryPixelSizes:h,primaryRasterIds:o}),{transformGrid:y}=u[0];if(!n||null==f||null==y)return{...u[0],pixelBlock:f};const x={rows:y.spacing[0],cols:y.spacing[1]};let b;return b=this.rasterJobHandler?(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:[f],srcMosaicSize:{width:f.width,height:f.height},destDimension:{width:e,height:r},coefs:y.coefficients,sampleSpacing:x,projectDirections:!1,gcsGrid:null,isUV:!1,interpolation:c,alignmentInfo:void 0,blockWidths:null},s)).pixelBlock:(0,pixelUtils.$i)(f,{width:e,height:r},y.coefficients,x,c),{extent:t,srcExtent:u[0].srcExtent,pixelBlock:b}}_hasSameStorageInfo(t,e){const{storageInfo:r,pixelSize:s,spatialReference:a,extent:i}=t,{storageInfo:o,pixelSize:n,spatialReference:c,extent:l}=e;return s.x===n.x&&s.y===n.y&&a.equals(c)&&i.equals(l)&&r.blockHeight===o.blockHeight&&r.blockWidth===o.blockWidth&&r.maximumPyramidLevel===o.maximumPyramidLevel}};(0,tslib_es6._)([(0,property.MZ)({type:String,json:{write:!0}})],n.prototype,"datasetFormat",void 0),(0,tslib_es6._)([(0,property.MZ)()],n.prototype,"tileType",void 0),(0,tslib_es6._)([(0,property.MZ)()],n.prototype,"rasterFunction",void 0),(0,tslib_es6._)([(0,property.MZ)()],n.prototype,"primaryRasters",void 0),n=(0,tslib_es6._)([(0,subclass.$)("esri.layers.support.rasterDatasets.FunctionRaster")],n);const c=n;var unitUtils=__webpack_require__("./node_modules/@arcgis/core/core/unitUtils.js"),PixelBlock=__webpack_require__("./node_modules/@arcgis/core/layers/support/PixelBlock.js");async function clipUtils_a(t,e,n){if("extent"===n.type)return function o(t,e,n){const{width:a,height:h}=t,o=new Uint8Array(a*h),r=e.width/a,x=e.height/h;if(n.width/r<.5||n.height/x<.5)return new PixelBlock.A({pixelType:t.pixelType,width:a,height:h,mask:o,pixels:[...t.pixels]});const{xmin:l,xmax:m,ymin:s,ymax:p}=e,{xmin:f,xmax:y,ymin:c,ymax:M}=n,u=Math.max(l,f),w=Math.min(m,y),d=Math.max(s,c),g=Math.min(p,M),T=.5*r,k=.5*x;if(w-u<T||g-d<k||w<l+T||u>m-T||d>p-k||g<s+k)return new PixelBlock.A({pixelType:t.pixelType,width:a,height:h,mask:o,pixels:[...t.pixels]});const A=Math.max(0,(u-l)/r),R=Math.min(a,Math.max(0,(w-l)/r)),U=Math.max(0,(p-g)/x),j=Math.min(h,Math.max(0,(p-d)/x)),E=Math.round(A),I=Math.round(R)-1,P=Math.round(U),v=Math.round(j)-1;if(E===I&&A%1>.5&&R%1<.5||P===v&&U%1>.5&&j%1<.5)return new PixelBlock.A({pixelType:t.pixelType,width:a,height:h,mask:o,pixels:[...t.pixels]});if(0===E&&0===P&&I===a&&v===h)return t;const b=t.mask;for(let i=P;i<=v;i++)for(let t=E;t<=I;t++){const e=i*a+t;o[e]=b?b[e]:255}return new PixelBlock.A({pixelType:t.pixelType,width:a,height:h,mask:o,pixels:[...t.pixels]})}(t,e,n);const{width:a,height:x}=t,l=new Uint8Array(a*x),{contains:m,intersects:s}=await Promise.all([__webpack_require__.e(63048),__webpack_require__.e(70635)]).then(__webpack_require__.bind(__webpack_require__,"./node_modules/@arcgis/core/geometry/geometryEngine.js"));return s(e,n)?"polyline"===n.type?function r(t,e,n){const{width:a,height:h}=t,o=new Uint8Array(a*h),r=e.width/a,x=e.height/h,{xmin:l,ymax:m}=e,{paths:s}=n,p=t.mask;for(let i=0;i<s.length;i++){const t=s[i];for(let e=0;e<t.length-1;e++){const[i,n]=t[e],[s,f]=t[e+1];let y=Math.floor((m-n)/x),c=Math.floor((m-f)/x);if(c<y){const t=y;y=c,c=t}y=Math.max(0,y),c=Math.min(h-1,c);const M=(s-i)/(f-n);for(let t=y;t<=c;t++){const e=t===y?Math.max(n,f):(h+1-t)*x,m=t===c?Math.min(n,f):e-x;let u=f===n?Math.floor((i-l)/r):Math.floor((M*(e-n)+i-l)/r),w=f===n?Math.floor((s-l)/r):Math.floor((M*(m-n)+i-l)/r);if(w<u){const t=u;u=w,w=t}const d=t*a;u=Math.max(0,u),w=Math.min(a-1,w);for(let t=d+u;t<=d+w;t++)o[t]=p?p[t]:255}}}return new PixelBlock.A({pixelType:t.pixelType,width:a,height:h,mask:o,pixels:[...t.pixels]})}(t,e,n):m(n,e)?t:function h(t,e,n){if(!t)return t;const{width:a,height:h}=t,o=e.width/a,r=e.height/h,{xmin:x,ymax:l}=e;let m;if("extent"===n.type){const t=(n.xmin-x)/o,e=(n.xmax-x)/o,i=(l-n.ymax)/r,a=(l-n.ymin)/r;m=[[[t,i],[t,a],[e,a],[e,i],[t,i]]]}else m=n.rings.map((t=>t.map((([t,e])=>[(t-x)/o,(l-e)/r]))));const s=document.createElement("canvas");s.width=a,s.height=h;const p=s.getContext("2d");p.fillStyle="#f00",m.forEach((t=>{p.beginPath(),p.moveTo(t[0][0],t[0][1]);for(let e=0;e<t.length;e++)p.lineTo(t[e][0],t[e][1]);p.closePath(),p.fill()}));const f=p.getImageData(0,0,a,h).data,y=t.mask,c=a*h,M=new Uint8Array(c);for(let i=0;i<c;i++)y&&!y[i]||(M[i]=f[4*i+3]>127?255:0);return new PixelBlock.A({pixelType:t.pixelType,width:a,height:h,mask:M,maskIsAlpha:!1,pixels:[...t.pixels]})}(t,e,n):new PixelBlock.A({pixelType:t.pixelType,width:a,height:x,mask:l,maskIsAlpha:!1,pixels:[...t.pixels]})}function x(t,i,a,h=!0){const{spatialReference:o}=t,{x:r,y:x}=function clipUtils_n(e,i){if(e.spatialReference.equals(i))return e;const n=(0,unitUtils.GA)(e.spatialReference),a=(0,unitUtils.GA)(i);if(n===a)return e;const h=n/a;return{x:e.x*h,y:e.y*h}}(a,o);let l,m,s;const p="extent"===i.type?i:i.extent;let{xmin:f,xmax:y,ymax:c,ymin:M}=p;const{xmin:u,ymax:w}=t.extent;return h?(f=u+(f>u?r*Math.round((f-u)/r):0),c=w-(c<w?x*Math.round((w-c)/x):0),y=u+(y>u?r*Math.round((y-u)/r):0),M=w-(M<w?x*Math.round((w-M)/x):0),l=new Extent.A({xmin:f,ymax:c,xmax:y,ymin:M,spatialReference:o}),m=Math.round(l.width/r),s=Math.round(l.height/x)):(m=Math.floor((y-f)/r+.8),s=Math.floor((c-M)/x+.8),f=u+(f>u?r*Math.floor((f-u)/r+.1):0),c=w-(c<w?x*Math.floor((w-c)/x+.1):0),y=f+m*r,M=c-s*x,l=new Extent.A({xmin:f,ymax:c,xmax:y,ymin:M,spatialReference:o})),{extent:l,width:m,height:s}}var rasterFunctionHelper=__webpack_require__("./node_modules/@arcgis/core/layers/support/rasterFunctions/rasterFunctionHelper.js"),stretchUtils=__webpack_require__("./node_modules/@arcgis/core/layers/support/rasterFunctions/stretchUtils.js"),rasterRendererHelper=__webpack_require__("./node_modules/@arcgis/core/renderers/support/rasterRendererHelper.js"),RasterSymbolizer=__webpack_require__("./node_modules/@arcgis/core/renderers/support/RasterSymbolizer.js"),ImageHistogramParameters=__webpack_require__("./node_modules/@arcgis/core/rest/support/ImageHistogramParameters.js"),dataUtils=__webpack_require__("./node_modules/@arcgis/core/views/2d/engine/flow/dataUtils.js"),SpatialReference=__webpack_require__("./node_modules/@arcgis/core/geometry/SpatialReference.js");const B=Logger.A.getLogger("esri.layers.mixins.ImageryTileMixin"),ImageryTileMixin_V=o=>{let V=class extends o{constructor(...e){super(...e),this._isConstructedFromFunctionRaster=!1,this._rasterJobHandler={instance:null,refCount:0,connectionPromise:null},this.bandIds=null,this.copyright=null,this.interpolation="nearest",this.multidimensionalSubset=null,this.raster=null,this.rasterInfo=null,this.sourceJSON=null,this.spatialReference=null,this.symbolizer=null,this._isConstructedFromFunctionRaster="Function"===e[0]?.raster?.datasetFormat}get fullExtent(){return this.rasterInfo?.extent}set multidimensionalDefinition(e){this._set("multidimensionalDefinition",e),this.updateRenderer()}set rasterFunction(e){"none"===e?.functionName?.toLowerCase()&&(e=void 0),this._set("rasterFunction",e),this.updateRasterFunction()}set url(e){this._set("url",(0,arcgisLayerUrl.Jf)(e,B))}set renderer(e){null==e&&null==this.rasterFunction?this._configDefaultRenderer("override"):(this._set("renderer",e),this.updateRenderer())}readRenderer(e,t,r){const n=t?.layerDefinition?.drawingInfo?.renderer;return(0,rasterRenderers.LF)(n,r)||void 0}async convertVectorFieldData(e,t){if(null==e||!this.rasterInfo)return null;const r=this._rasterJobHandler.instance,i=this.rasterInfo.dataType;return r?r.convertVectorFieldData({pixelBlock:e,dataType:i},t):(0,vectorFieldUtils.FI)(e,i)}async computeStatisticsHistograms(e,t){e=(0,ensureType.PZ)(ImageHistogramParameters.A,e).clone();const{rasterInfo:r}=this,{geometry:i}=e;if(null==i)throw new core_Error.A("imagery-tile-mixin:compute-statistics-histograms","geometry must be specified");let n=i;const{spatialReference:o}=r;i.spatialReference.equals(o)||(await(0,rasterProjectionHelper.Hh)(),n="extent"===i.type?(0,rasterProjectionHelper._l)(i,o):(0,rasterProjectionHelper.uk)(i,o));const a=e.pixelSize??new Point.A({x:r.pixelSize.x,y:r.pixelSize.y,spatialReference:o}),{extent:u,width:c,height:d}=x(r,n,a),m=await this.fetchPixels(u,c,d,{...t,interpolation:"nearest"});if(null==m.pixelBlock)throw new core_Error.A("imagery-tile-mixin:compute-statistics-histograms","failed to fetch pixels");const h=await clipUtils_a(m.pixelBlock,u,n),p=this._rasterJobHandler.instance;return p?p.computeStatisticsHistograms({pixelBlock:h},t):(0,stretchUtils.eH)(h)}async createFlowMesh(e,t){const r=this._rasterJobHandler.instance;return r?r.createFlowMesh(e,t):(0,dataUtils.CW)(e.meshType,e.simulationSettings,e.flowData,null!=t.signal?t.signal:(new AbortController).signal)}normalizeRasterFetchOptions(e){const{multidimensionalInfo:t}=this.rasterInfo??{};if(null==t)return e;let r=e.multidimensionalDefinition||this.multidimensionalDefinition;r?.length||(r=(0,multidimensionalUtils.fy)(this.raster.rasterInfo,{multidimensionalSubset:this.multidimensionalSubset}));const i=e.timeExtent||this.timeExtent;if(null!=r&&null!=i&&(null!=i.start||null!=i.end)){r=r.map((e=>e.clone()));const n=t.variables.find((({name:e})=>e===r[0].variableName))?.dimensions?.find((({name:e})=>"StdTime"===e)),s=r.find((({dimensionName:e})=>"StdTime"===e));if(!n||!s)return{...e,multidimensionalDefinition:null};const{start:o,end:a}=i,l=null==o?null:o.getTime(),u=null==a?null:a.getTime(),c=l??u,d=u??l;if(null!=n.values){const e=n.values.filter((e=>{if(Array.isArray(e)){if(c===d)return e[0]<=c&&e[1]>=c;const t=e[0]<=c&&e[1]>c||e[0]<d&&e[1]>=d,r=e[0]>=c&&e[1]<=d||e[0]<c&&e[1]>d;return t||r}return c===d?e===c:e>=c&&e<=d}));if(e.length){const t=e.sort(((e,t)=>{const r=Array.isArray(e)?e[0]:e,i=Array.isArray(e)?e[1]:e,n=Array.isArray(t)?t[0]:t,s=Array.isArray(t)?t[1]:t;return c===d?r-n:Math.abs(i-d)-Math.abs(s-d)}))[0];s.values=[t]}else r=null}else if(n.hasRegularIntervals&&n.extent){const[e,t]=n.extent;c>t||d<e?r=null:s.values=c===d?[c]:[Math.max(e,c),Math.min(t,d)]}}return null!=r&&(0,multidimensionalUtils.sx)(r,this.multidimensionalSubset)?{...e,multidimensionalDefinition:null}:{...e,multidimensionalDefinition:r}}async updateRasterFunction(){if(!this.loaded||"imagery-tile"!==this.type||!this.rasterFunction&&!this._cachedRasterFunctionJson||JSON.stringify(this.rasterFunction)===JSON.stringify(this._cachedRasterFunctionJson))return;if(this._isConstructedFromFunctionRaster&&"Function"===this.raster.datasetFormat){const e=this.raster.rasterFunction.toJSON();return!this.rasterFunction&&e&&this._set("rasterFunction",RasterFunction.A.fromJSON(e)),void(this._cachedRasterFunctionJson=this.rasterFunction?.toJSON())}let e,t=this.raster,r=!1;"Function"===t.datasetFormat?(e=t.primaryRasters.rasters,t=e[0],r=!0):e=[t];const{rasterFunction:i}=this;if(i){const r={raster:t};e.length>1&&e.forEach((e=>r[e.url]=e));const n=(0,rasterFunctionHelper.vt)(i.functionDefinition?.toJSON()??i.toJSON(),r),s=new c({rasterFunction:n});s.rasterJobHandler=this._rasterJobHandler.instance,await s.open(),this._cachedRasterFunctionJson=this.rasterFunction?.toJSON(),this.raster=s}else this.raster=t,this._cachedRasterFunctionJson=null,await t.when();if(this._cachedRendererJson=null,!r&&!i)return;const{bandIds:n}=this,{bandCount:s}=this.raster.rasterInfo,o=n?.length?n.some((e=>e>=s)):s>=3;n&&(o||this.renderer&&"raster-stretch"!==this.renderer.type)&&this._set("bandIds",null),this._configDefaultRenderer("auto")}async updateRenderer(){const{loaded:e,symbolizer:t}=this;if(!e||!t||!this.renderer)return;const{rasterInfo:r}=this.raster,i=(0,multidimensionalUtils.j5)(r,{multidimensionalDefinition:this.multidimensionalDefinition,multidimensionalSubset:this.multidimensionalSubset}),n=i?.name,s=(0,rasterRendererHelper.$P)({...this.renderer.toJSON(),variableName:n});if(JSON.stringify(this._cachedRendererJson)===JSON.stringify(s))return;const o=this._rasterJobHandler.instance;o&&(t.rasterInfo=(0,rasterRendererHelper.m7)(r,n),t.rendererJSON=s,t.bind(),await o.updateSymbolizer(t),this._cachedRendererJson=s)}async applyRenderer(e,t){const r=e?.pixelBlock;if(!(null!=r&&r.pixels&&r.pixels.length>0))return null;let i;await this.updateRenderer();const n=this._rasterJobHandler.instance,s=this.bandIds??[];return i=n?await n.symbolize({...e,simpleStretchParams:t,bandIds:s}):this.symbolizer.symbolize({...e,simpleStretchParams:t,bandIds:s}),i}getTileUrl(e,t,r){return"RasterTileServer"===this.raster.datasetFormat?`${this.url}/tile/${e}/${t}/${r}`:""}getCompatibleTileInfo(e,t,r=!1){if(!this.loaded||null==t)return null;if(r&&e.equals(this.spatialReference))return this.tileInfo;const i=(0,spatialReferenceUtils.Vp)(e);return TileInfo.A.create({size:256,spatialReference:e,origin:i?{x:i.origin[0],y:i.origin[1]}:{x:t.xmin,y:t.ymax}})}getCompatibleFullExtent(e){return this.loaded?(this._compatibleFullExtent&&this._compatibleFullExtent.spatialReference.equals(e)||(this._compatibleFullExtent=this.raster.computeExtent(e)),this._compatibleFullExtent):null}async fetchTile(e,t,r,i={}){if(L(this),i.requestAsImageElement){const s=this.getTileUrl(e,t,r);return(0,request.A)(s,{responseType:"image",query:{...this.refreshParameters,...this.raster.ioConfig.customFetchParameters},signal:i.signal}).then((e=>e.data))}const{rasterInfo:s}=this;if(null!=s.multidimensionalInfo&&null==(i=this.normalizeRasterFetchOptions(i)).multidimensionalDefinition){const n=i.tileInfo||s.storageInfo.tileInfo;return{extent:this.raster.getTileExtentFromTileInfo(e,t,r,n),pixelBlock:null}}return await this._initJobHandler(),await this.updateRasterFunction(),"raster-shaded-relief"===this.renderer?.type&&(i={...i,buffer:{cols:1,rows:1}}),this.raster.fetchTile(e,t,r,i)}async fetchPixels(e,t,r,i={}){return null!=this.rasterInfo.multidimensionalInfo&&null==(i=this.normalizeRasterFetchOptions(i)).multidimensionalDefinition?{extent:e,pixelBlock:null}:(await this._initJobHandler(),await this.updateRasterFunction(),t=Math.round(t),r=Math.round(r),this.raster.fetchPixels(e,t,r,i))}async identify(e,t={}){const{raster:r,rasterInfo:i}=this;if(null!=i.multidimensionalInfo&&!(i.hasMultidimensionalTranspose&&((0,multidimensionalUtils.DY)(t.multidimensionalDefinition)||t.transposedVariableName||t.timeExtent)||null!=(t=this.normalizeRasterFetchOptions(t)).multidimensionalDefinition))return{location:e,value:null};const n=this.multidimensionalSubset?.areaOfInterest;if(n&&!n.contains(e))throw new core_Error.A("imagery-tile-mixin:identify","the request cannot be fulfilled when falling outside of the multidimensional subset");return r.identify(e,t)}increaseRasterJobHandlerUsage(){this._rasterJobHandler.refCount++}decreaseRasterJobHandlerUsage(){this._rasterJobHandler.refCount--,this._rasterJobHandler.refCount<=0&&this._shutdownJobHandler()}hasStandardTime(){const e=this.rasterInfo?.multidimensionalInfo;if(null==e||"standard-time"!==this.rasterInfo?.dataType)return!1;const t=this.multidimensionalDefinition,r=t?.[0]?.variableName;return e.variables.some((e=>e.name===r&&(!t?.[0].dimensionName||e.dimensions.some((e=>"StdTime"===e.name)))))}getStandardTimeValue(e){return new Date(24*(e-25569)*3600*1e3).toString()}getMultidimensionalSubsetVariables(e){const t=e??this.rasterInfo?.multidimensionalInfo;return(0,multidimensionalUtils.z2)(this.multidimensionalSubset,t)}_configDefaultSettings(){this._configDefaultInterpolation(),this.multidimensionalDefinition||(this.multidimensionalDefinition=(0,multidimensionalUtils.fy)(this.raster.rasterInfo,{multidimensionalSubset:this.multidimensionalSubset})),this.rasterFunction&&"Function"===this.raster.datasetFormat&&(this._cachedRasterFunctionJson=this.rasterFunction.toJSON()),this._configDefaultRenderer()}_initJobHandler(){if(null!=this._rasterJobHandler.connectionPromise)return this._rasterJobHandler.connectionPromise;const e=new RasterJobHandler.A;return this._rasterJobHandler.connectionPromise=e.initialize().then((async()=>{L(this),this._rasterJobHandler.instance=e,this.raster.rasterJobHandler=e,"Function"===this.raster.datasetFormat&&this.raster.syncJobHandler(),this.rasterFunction&&await this.updateRasterFunction().catch((()=>{})),this.renderer&&this.updateRenderer()})).catch((()=>{})),this._rasterJobHandler.connectionPromise}_shutdownJobHandler(){this._rasterJobHandler.instance&&this._rasterJobHandler.instance.destroy(),this._rasterJobHandler.instance=null,this._rasterJobHandler.connectionPromise=null,this._rasterJobHandler.refCount=0,this._cachedRendererJson=null,this.raster&&(this.raster.rasterJobHandler=null)}_configDefaultInterpolation(){if(null==this.interpolation){L(this);const{raster:e}=this,t=(0,rasterRendererHelper.w6)(e.rasterInfo,e.tileType,this.sourceJSON?.defaultResamplingMethod);this._set("interpolation",t)}}_configDefaultRenderer(e="no"){L(this);const{rasterInfo:t}=this.raster;!this.bandIds&&t.bandCount>1&&(this.bandIds=(0,rasterRendererHelper.ci)(t));const r=(0,multidimensionalUtils.j5)(t,{multidimensionalDefinition:this.multidimensionalDefinition,multidimensionalSubset:this.multidimensionalSubset}),i=r?.name;if(!this.renderer||"override"===e){const e=(0,rasterRendererHelper.PD)(t,{bandIds:this.bandIds,variableName:i}),r=t.statistics,n=r&&r.length>0?r[0]:null,s=n?.max??0,o=n?.min??0;"WCSServer"===this.raster.datasetFormat&&"raster-stretch"===e.type&&(s>1e24||o<-1e24)&&(e.dynamicRangeAdjustment=!0,e.statistics=null,"none"===e.stretchType&&(e.stretchType="min-max")),this.renderer=e}const n=(0,rasterRendererHelper.$P)({...this.renderer.toJSON(),variableName:i}),s=(0,rasterRendererHelper.m7)(t,i);this.symbolizer?(this.symbolizer.rendererJSON=n,this.symbolizer.rasterInfo=s):this.symbolizer=new RasterSymbolizer.A({rendererJSON:n,rasterInfo:s});const o=this.symbolizer.bind();if(o.success){if("auto"===e){const{colormap:e}=this.raster.rasterInfo,t=this.renderer;if(null!=e&&"raster-colormap"===t.type){const e=(0,rasterRendererHelper.PD)(this.raster.rasterInfo);JSON.stringify(e)!==JSON.stringify(t)&&this._configDefaultRenderer("override")}else if("raster-stretch"===t.type){const e=this.bandIds?.length,r=t.statistics?.length;!t.dynamicRangeAdjustment&&r&&e&&r!==e&&this._configDefaultRenderer("override")}}}else B.warn("imagery-tile-mixin",o.error||"The given renderer is not supported by the layer."),"auto"===e&&this._configDefaultRenderer("override")}};function L(e){if(!e.raster||!e.rasterInfo)throw new core_Error.A("imagery-tile","no raster")}return(0,tslib_es6._)([(0,property.MZ)({clonable:!1})],V.prototype,"_cachedRendererJson",void 0),(0,tslib_es6._)([(0,property.MZ)({clonable:!1})],V.prototype,"_cachedRasterFunctionJson",void 0),(0,tslib_es6._)([(0,property.MZ)({clonable:!1})],V.prototype,"_compatibleFullExtent",void 0),(0,tslib_es6._)([(0,property.MZ)({clonable:!1})],V.prototype,"_isConstructedFromFunctionRaster",void 0),(0,tslib_es6._)([(0,property.MZ)({clonable:!1})],V.prototype,"_rasterJobHandler",void 0),(0,tslib_es6._)([(0,property.MZ)()],V.prototype,"bandIds",void 0),(0,tslib_es6._)([(0,property.MZ)({json:{origins:{service:{read:{source:"copyrightText"}}}}})],V.prototype,"copyright",void 0),(0,tslib_es6._)([(0,property.MZ)({json:{read:!1}})],V.prototype,"fullExtent",null),(0,tslib_es6._)([(0,property.MZ)()],V.prototype,"interpolation",void 0),(0,tslib_es6._)([(0,property.MZ)()],V.prototype,"ioConfig",void 0),(0,tslib_es6._)([(0,property.MZ)({type:[DimensionalDefinition.A],json:{write:!0}})],V.prototype,"multidimensionalDefinition",null),(0,tslib_es6._)([(0,property.MZ)({type:MultidimensionalSubset.A,json:{write:!0}})],V.prototype,"multidimensionalSubset",void 0),(0,tslib_es6._)([(0,property.MZ)()],V.prototype,"raster",void 0),(0,tslib_es6._)([(0,property.MZ)({type:RasterFunction.A,json:{name:"renderingRule",write:!0}})],V.prototype,"rasterFunction",null),(0,tslib_es6._)([(0,property.MZ)()],V.prototype,"rasterInfo",void 0),(0,tslib_es6._)([(0,property.MZ)()],V.prototype,"sourceJSON",void 0),(0,tslib_es6._)([(0,property.MZ)({readOnly:!0,type:SpatialReference.A,json:{read:!1}})],V.prototype,"spatialReference",void 0),(0,tslib_es6._)([(0,property.MZ)({type:TileInfo.A})],V.prototype,"tileInfo",void 0),(0,tslib_es6._)([(0,property.MZ)(commonProperties.OZ)],V.prototype,"url",null),(0,tslib_es6._)([(0,property.MZ)({types:rasterRenderers.uy,json:{name:"layerDefinition.drawingInfo.renderer",write:{overridePolicy(){const e="raster-stretch"===this.renderer?.type&&"none"===this.renderer.stretchType&&!this.renderer.useGamma;return{enabled:!this.loaded||"Raster"===this.raster.tileType||!e}}},origins:{"web-scene":{types:rasterRenderers.Gj,name:"layerDefinition.drawingInfo.renderer",write:{overridePolicy:e=>({enabled:e&&"vector-field"!==e.type&&"flow"!==e.type})}}}}})],V.prototype,"renderer",null),(0,tslib_es6._)([(0,reader.w)("renderer")],V.prototype,"readRenderer",null),(0,tslib_es6._)([(0,property.MZ)({clonable:!1})],V.prototype,"symbolizer",void 0),V=(0,tslib_es6._)([(0,subclass.$)("esri.layers.ImageryTileMixin")],V),V};var OperationalLayer=__webpack_require__("./node_modules/@arcgis/core/layers/mixins/OperationalLayer.js"),PortalLayer=__webpack_require__("./node_modules/@arcgis/core/layers/mixins/PortalLayer.js"),RefreshableLayer=__webpack_require__("./node_modules/@arcgis/core/layers/mixins/RefreshableLayer.js"),ScaleRangeLayer=__webpack_require__("./node_modules/@arcgis/core/layers/mixins/ScaleRangeLayer.js"),TemporalLayer=__webpack_require__("./node_modules/@arcgis/core/layers/mixins/TemporalLayer.js"),Field=__webpack_require__("./node_modules/@arcgis/core/layers/support/Field.js"),rasterEnums=__webpack_require__("./node_modules/@arcgis/core/layers/support/rasterEnums.js"),RasterInfo=__webpack_require__("./node_modules/@arcgis/core/layers/support/RasterInfo.js"),byteStreamUtils=__webpack_require__("./node_modules/@arcgis/core/layers/support/rasterDatasets/byteStreamUtils.js");function t(e){const t=e.fields,r=e.records,n=t.some((e=>"oid"===e.name.toLowerCase()))?"OBJECTID":"OID",i=[{name:n,type:"esriFieldTypeOID",alias:"OID"}].concat(t.map((e=>({name:e.name,type:"esriFieldType"+e.typeName,alias:e.name})))),s=i.map((e=>e.name)),a=[];let o=0,l=0;return r.forEach((e=>{const t={};for(t[n]=o++,l=1;l<s.length;l++)t[s[l]]=e[l-1];a.push({attributes:t})})),{displayFieldName:"",fields:i,features:a}}class DBFParser_r{static get supportedVersions(){return[5]}static parse(r){const n=new DataView(r),i=3&n.getUint8(0);if(3!==i)return{header:{version:i},recordSet:null};const s=n.getUint32(4,!0),a=n.getUint16(8,!0),o=n.getUint16(10,!0),l={version:i,recordCount:s,headerByteCount:a,recordByteCount:o};let p=32;const g=[],u=[];let d;if(3===i){for(;13!==n.getUint8(p);)d=String.fromCharCode(n.getUint8(p+11)).trim(),g.push({name:(0,byteStreamUtils.w)(new Uint8Array(r,p,11)),type:d,typeName:["String","Date","Double","Boolean","String","Integer"][["C","D","F","L","M","N"].indexOf(d)],length:n.getUint8(p+16)}),p+=32;if(p+=1,g.length>0)for(;u.length<s&&r.byteLength-p>o;){const t=[];32===n.getUint8(p)?(p+=1,g.forEach((n=>{if("C"===n.type)t.push((0,byteStreamUtils.w)(new Uint8Array(r,p,n.length)).trim());else if("N"===n.type)t.push(parseInt(String.fromCharCode.apply(null,new Uint8Array(r,p,n.length)).trim(),10));else if("F"===n.type)t.push(parseFloat(String.fromCharCode.apply(null,new Uint8Array(r,p,n.length)).trim()));else if("D"===n.type){const e=String.fromCharCode.apply(null,new Uint8Array(r,p,n.length)).trim();t.push(new Date(parseInt(e.substring(0,4),10),parseInt(e.substring(4,6),10)-1,parseInt(e.substring(6,8),10)))}p+=n.length})),u.push(t)):p+=o}}return{header:l,fields:g,records:u,recordSet:t({fields:g,records:u})}}}var utils=__webpack_require__("./node_modules/@arcgis/core/layers/support/rasterTransforms/utils.js");const g=new Map;g.set("int16","esriFieldTypeSmallInteger"),g.set("int32","esriFieldTypeInteger"),g.set("int64","esriFieldTypeInteger"),g.set("float32","esriFieldTypeSingle"),g.set("float64","esriFieldTypeDouble"),g.set("text","esriFieldTypeString");let CloudRaster_x=class extends U{constructor(){super(...arguments),this.storageInfo=null,this.datasetFormat="CRF"}async open(e){await this.init();const{data:r}=await this.request(this.url+"/conf.json",{signal:e?.signal});if(!this._validateHeader(r))throw new core_Error.A("cloudraster:open","Invalid or unsupported conf.json.");this.datasetName=this.url.slice(this.url.lastIndexOf("/")+1);const{storageInfo:o,rasterInfo:i}=this._parseHeader(r);if("thematic"===i.dataType){const e=await this._fetchAuxiliaryInformation();i.attributeTable=e}this._set("storageInfo",o),this._set("rasterInfo",i),this.ioConfig.retryCount=this.ioConfig.retryCount||0}async fetchRawTile(e,t,r,o={}){const{transposeInfo:i}=this.rasterInfo.storageInfo,{transposedVariableName:s}=o,a=!(!i||!s),n=a?0:this.rasterInfo.storageInfo.maximumPyramidLevel-e;if(n<0)return null;const l=this._buildCacheFilePath(n,t,r,o.multidimensionalDefinition,s),f=this._getIndexRecordFromBundle(t,r,a),m=await this.request(l,{range:{from:0,to:this.storageInfo.headerSize-1},responseType:"array-buffer",signal:o.signal});if(!m)return null;const c=new Uint8Array(m.data),p=this._getTileEndAndContentType(c,f);if(0===p.recordSize)return null;const d=await this.request(l,{range:{from:p.position,to:p.position+p.recordSize},responseType:"array-buffer",signal:o.signal});if(!d)return null;const[u,h]=this._getTileSize(a);return this.decodePixelBlock(d.data,{width:u,height:h,planes:null,pixelType:null,returnInterleaved:a})}_validateHeader(e){return e&&"RasterInfo"===e.type&&!["origin","extent","geodataXform","LODInfos","blockWidth","blockHeight","bandCount","pixelType","pixelSizeX","pixelSizeY","format","packetSize"].some((t=>!e[t]))}_parseHeader(e){const t=["u1","u2","u4","u8","s8","u16","s16","u32","s32","f32","f64"][e.pixelType],{bandCount:r,colormap:o,blockWidth:l,blockHeight:f,firstPyramidLevel:m,maximumPyramidLevel:c}=e,p=e.statistics?.map((e=>({min:e.min,max:e.max,avg:e.mean,stddev:e.standardDeviation,median:e.median,mode:e.mode}))),g=e.histograms?.[0]?.counts?.length?e.histograms:null,x=e.extent.spatialReference,S=e.geodataXform?.spatialReference,I=new SpatialReference.A(x?.wkid||x?.wkt||x?.wkt2?x:S);let w=new Extent.A({xmin:e.extent.xmin,ymin:e.extent.ymin,xmax:e.extent.xmax,ymax:e.extent.ymax,spatialReference:I});const _=new Point.A({x:e.pixelSizeX,y:e.pixelSizeY,spatialReference:I}),v=Math.round((w.xmax-w.xmin)/_.x),b=Math.round((w.ymax-w.ymin)/_.y),z=this._parseTransform(e.geodataXform),T=z?w:null;z&&(w=z.forwardTransform(w),_.x=(w.xmax-w.xmin)/v,_.y=(w.ymax-w.ymin)/b);const k=e.properties??{},j=e.format.toLowerCase().replace("cache/",""),C=new Point.A(e.origin.x,e.origin.y,I);let R,F,P,H;if(o?.colors)for(R=[],F=0;F<o.colors.length;F++)P=o.colors[F],H=o.values?o.values[F]:F,R.push([H,255&P,P<<16>>>24,P<<8>>>24,P>>>24]);const D=e.LODInfos,L=[];for(F=0;F<D.levels.length;F++)L.push(new LOD.A({level:D.levels[F],resolution:D.resolutions[F],scale:96/.0254*D.resolutions[F]}));const M=new TileInfo.A({dpi:96,lods:L,format:j,origin:C,size:[l,f],spatialReference:I}),O={recordSize:8,packetSize:e.packetSize,headerSize:e.packetSize*e.packetSize*8+64},B=[{maxCol:Math.ceil(v/l)-1,maxRow:Math.ceil(b/f)-1,minCol:0,minRow:0}];let $=2;if(c>0)for(F=0;F<c;F++)B.push({maxCol:Math.ceil(v/$/l)-1,maxRow:Math.ceil(b/$/f)-1,minCol:0,minRow:0}),$*=2;const N=e.mdInfo;let q=null;if(N&&k._yxs){const e=k._yxs;q={packetSize:e.PacketSize,tileSize:[e.TileXSize,e.TileYSize]}}return{storageInfo:O,rasterInfo:new RasterInfo.A({width:v,height:b,pixelType:t,bandCount:r,extent:w,nativeExtent:T,transform:z,spatialReference:I,pixelSize:_,keyProperties:k,statistics:p,histograms:g,multidimensionalInfo:N,colormap:R,storageInfo:new RasterStorageInfo.A({blockWidth:l,blockHeight:f,pyramidBlockWidth:l,pyramidBlockHeight:f,origin:C,tileInfo:M,transposeInfo:q,firstPyramidLevel:m,maximumPyramidLevel:c,blockBoundary:B})})}}_parseTransform(e){if(!(0,utils.J)(e))throw new core_Error.A("cloudraster:open","the data contains unsupported geodata transform types");const r=(0,utils.l)(e);if("identity"===r.type)return null;if("polynomial"!==r.type||!r.forwardCoefficients?.length||!r.inverseCoefficients?.length)throw new core_Error.A("cloudraster:open","the data contains unsupported geodata transforms - both forward and inverse coefficients are required currently");return r}async _fetchAuxiliaryInformation(e){const t=this.request(this.url+"/conf.vat.json",{signal:e}).then((e=>e.data)).catch((()=>null)),r=this.request(this.url+"/conf.vat.dbf",{responseType:"array-buffer",signal:e}).then((e=>e.data)).catch((()=>null)),o=await Promise.all([t,r]);let i;if(o[0]){let e=o[0].fields;const t=o[0].values;if(e&&t){e=e.map((e=>({type:"OID"===e.name?"esriFieldTypeOID":g.get(e.type),name:e.name,alias:e.alias||e.name})));const r=t.map((e=>({attributes:e})));e&&t&&(i={fields:e,features:r})}}return!i&&o[1]&&(i=DBFParser_r.parse(o[1]).recordSet),FeatureSet.A.fromJSON(i)}_buildCacheFilePath(e,t,r,o,i){const s=this._getPackageSize(!!i),a=Math.floor(t/s)*s,n=Math.floor(r/s)*s,l="R"+this._toHexString4(a)+"C"+this._toHexString4(n);let f="L";f+=e>=10?e.toString():"0"+e.toString();const{multidimensionalInfo:m}=this.rasterInfo,c=o?.[0];if(null==m||!c)return`${this.url}/_alllayers/${f}/${l}.bundle`;let p="_yxs";if(!i){p=m.variables.find((e=>e.name===c.variableName)).dimensions[0].values.indexOf(c.values[0]).toString(16);const e=4-p.length;for(let t=0;t<e;t++)p="0"+p;p="S"+p}const d=this._getVariableFolderName(i||c.variableName);return`${this.url}/_alllayers/${d}/${p}/${f}/${l}.bundle`}_getPackageSize(e=!1){const{transposeInfo:t}=this.rasterInfo.storageInfo;return e&&null!=t?t.packetSize??0:this.storageInfo.packetSize}_getTileSize(e=!1){const{storageInfo:t}=this.rasterInfo,{transposeInfo:r}=t;return e&&null!=r?r.tileSize:t.tileInfo.size}_getVariableFolderName(e){return""===(e=e.trim())?"_v":e.replaceAll(/[\{|\}\-]/g,"_").replace("\\*","_v")}_getIndexRecordFromBundle(e,t,r=!1){const o=this._getPackageSize(r),i=o*(e%o)+t%o;if(i<0)throw new Error("Invalid level / row / col");return 20+i*this.storageInfo.recordSize+44}_getTileEndAndContentType(e,t){const r=e.subarray(t,t+8);let o,i=0;for(o=0;o<5;o++)i|=(255&r[o])<<8*o;const s=0xffffffffff&i;for(i=0,o=5;o<8;o++)i|=(255&r[o])<<8*(o-5);return{position:s,recordSize:0xffffffffff&i}}_toHexString4(e){let t=e.toString(16);if(4!==t.length){let e=4-t.length;for(;e-- >0;)t="0"+t}return t}};(0,tslib_es6._)([(0,property.MZ)({readOnly:!0})],CloudRaster_x.prototype,"storageInfo",void 0),(0,tslib_es6._)([(0,property.MZ)({type:String,json:{write:!0}})],CloudRaster_x.prototype,"datasetFormat",void 0),CloudRaster_x=(0,tslib_es6._)([(0,subclass.$)("esri.layers.support.rasterDatasets.CloudRaster")],CloudRaster_x);const S=CloudRaster_x;let InMemoryRaster_c=class extends U{constructor(){super(...arguments),this.datasetFormat="MEMORY",this.data=null}async open(t){await this.init();const e=this.data,{pixelBlock:s,statistics:r,histograms:i,name:a,keyProperties:n,nativeExtent:m,transform:c}=this.data,{width:h,height:f,pixelType:u}=s,d=e.extent??new Extent.A({xmin:-.5,ymin:.5,xmax:h-.5,ymax:f-.5,spatialReference:new SpatialReference.A({wkid:3857})}),y=e.isPseudoSpatialReference??!e.extent,x={x:d.width/h,y:d.height/f},g=new RasterInfo.A({width:h,height:f,pixelType:u,extent:d,nativeExtent:m,transform:c,pixelSize:x,spatialReference:d.spatialReference,bandCount:s.pixels.length,keyProperties:n||{},statistics:r,isPseudoSpatialReference:y,histograms:i});this.createRemoteDatasetStorageInfo(g,512,512),this._set("rasterInfo",g),this.updateTileInfo(),await this._buildInMemoryRaster(s,{width:512,height:512},t),this.datasetName=a,this.url="/InMemory/"+a}fetchRawTile(t,e,s,r={}){const i=this._pixelBlockTiles.get(`${t}/${e}/${s}`);return Promise.resolve(i)}async _buildInMemoryRaster(t,r,i){const o=this.rasterInfo.storageInfo.maximumPyramidLevel,a=this.rasterJobHandler?this.rasterJobHandler.split({pixelBlock:t,tileSize:r,maximumPyramidLevel:o},i):Promise.resolve((0,pixelUtils.lD)(t,r,o)),l=null!=this.rasterInfo.statistics,p=null!=this.rasterInfo.histograms,c=l?Promise.resolve({statistics:null,histograms:null}):this.rasterJobHandler?this.rasterJobHandler.estimateStatisticsHistograms({pixelBlock:t},i):Promise.resolve((0,stretchUtils.f4)(t)),h=await(0,promiseUtils.Lx)([a,c]);if(!h[0].value&&h[1].value)throw new core_Error.A("inmemory-raster:open","failed to build in memory raster");this._pixelBlockTiles=h[0].value,l||(this.rasterInfo.statistics=h[1].value?.statistics),p||(this.rasterInfo.histograms=h[1].value?.histograms)}};(0,tslib_es6._)([(0,property.MZ)({type:String,json:{write:!0}})],InMemoryRaster_c.prototype,"datasetFormat",void 0),(0,tslib_es6._)([(0,property.MZ)()],InMemoryRaster_c.prototype,"data",void 0),InMemoryRaster_c=(0,tslib_es6._)([(0,subclass.$)("esri.layers.support.rasterDatasets.InMemoryRaster")],InMemoryRaster_c);const InMemoryRaster_h=InMemoryRaster_c;function xmlUtilities_n(e,t){if(!e||!t)return[];let l=t;t.includes("/")?(l=t.slice(0,t.indexOf("/")),t=t.slice(t.indexOf("/")+1)):t="";const r=[];if(t){const u=xmlUtilities_n(e,l);for(let e=0;e<u.length;e++)xmlUtilities_n(u[e],t).forEach((n=>r.push(n)));return r}const u=e.getElementsByTagNameNS("*",l);if(!u||0===u.length)return[];for(let n=0;n<u.length;n++)r.push(u[n]||u.item(n));return r}function xmlUtilities_e(t,l){if(!t||!l)return null;let r=l;l.includes("/")?(r=l.slice(0,l.indexOf("/")),l=l.slice(l.indexOf("/")+1)):l="";const u=xmlUtilities_n(t,r);return u.length>0?l?xmlUtilities_e(u[0],l):u[0]:null}function xmlUtilities_t(n,t=null){const l=t?xmlUtilities_e(n,t):n;let r;return l?(r=l.textContent||l.nodeValue,r?r.trim():null):null}function u(n,e){return function l(e,t){const l=xmlUtilities_n(e,t),r=[];let u;for(let n=0;n<l.length;n++)u=l[n].textContent||l[n].nodeValue,u&&(u=u.trim(),""!==u&&r.push(u));return r}(n,e).map((n=>Number(n)))}function xmlUtilities_o(n,e){const l=xmlUtilities_t(n,e);return Number(l)}function xmlUtilities_i(n,e){const t=n?.nodeName?.toLowerCase(),l=e.toLowerCase();return t.slice(t.lastIndexOf(":")+1)===l}var PolynomialTransform=__webpack_require__("./node_modules/@arcgis/core/layers/support/rasterTransforms/PolynomialTransform.js");function pamParser_u(e,t){if(!e||!t)return null;const n=[];for(let r=0;r<e.length;r++)n.push(e[r]),n.push(t[r]);return n}function d(e){if(!e)return null;let n=Number(e);if(!isNaN(n)&&0!==n)return new SpatialReference.A({wkid:n});if(e=String(e).trim(),(0,spatialReferenceUtils.jp)(e))return new SpatialReference.A({wkt2:e});const r=e.toUpperCase();if(r.startsWith("COMPD_CS")){if(!r.includes("VERTCS")||!r.includes("GEOGCS")&&!r.startsWith("PROJCS"))return null;const t=r.indexOf("VERTCS"),s=r.indexOf("PROJCS"),a=s>-1?s:r.indexOf("GEOGCS");if(-1===a)return null;const i=e.slice(a,e.lastIndexOf("]",t)+1).trim(),l=e.slice(t,e.lastIndexOf("]")).trim();n=p(i);const o=new SpatialReference.A(n?{wkid:n}:{wkt:i}),u=p(l);return u&&(o.vcsWkid=u),o}return r.startsWith("GEOGCS")||r.startsWith("PROJCS")?(n=p(e),new SpatialReference.A(0!==n?{wkid:n}:{wkt:e})):null}function p(e){const t=e.replaceAll("]","[").replaceAll('"',"").split("[").map((e=>e.trim())).filter((e=>""!==e)),n=t[t.length-1].split(","),r=n[0]?.toLowerCase();if(("epsg"===r||"esri"===r)&&e.endsWith('"]]')){const e=Number(n[1]);if(!isNaN(e)&&0!==e)return e}return 0}function pamParser_S(t){if("pamdataset"!==t?.documentElement.tagName?.toLowerCase())return{};const a={spatialReference:null,transform:null,metadata:{},rasterBands:[],statistics:null,histograms:null};t.documentElement.childNodes.forEach((e=>{if(1===e.nodeType)if(xmlUtilities_i(e,"SRS")){if(!a.spatialReference){const t=xmlUtilities_t(e);a.spatialReference=d(t)}}else if(xmlUtilities_i(e,"Metadata"))if("xml:ESRI"===e.getAttribute("domain")){const{spatialReference:t,transform:n}=function pamParser_c(e){const t=xmlUtilities_e(e,"GeodataXform"),n=d(xmlUtilities_o(t,"SpatialReference/WKID")||xmlUtilities_t(t,"SpatialReference/WKT"));if("typens:PolynomialXform"!==t.getAttribute("xsi:type"))return{spatialReference:n,transform:null};const s=xmlUtilities_o(t,"PolynomialOrder")??1,f=u(t,"CoeffX/Double"),c=u(t,"CoeffY/Double"),m=u(t,"InverseCoeffX/Double"),p=u(t,"InverseCoeffY/Double"),S=pamParser_u(f,c),C=pamParser_u(m,p);return{spatialReference:n,transform:S&&C&&S.length&&C.length?new PolynomialTransform.A({spatialReference:n,polynomialOrder:s,forwardCoefficients:S,inverseCoefficients:C}):null}}(e);a.transform=n,a.spatialReference||(a.spatialReference=t)}else xmlUtilities_n(e,"MDI").forEach((e=>a.metadata[e.getAttribute("key")]=xmlUtilities_t(e)));else if(xmlUtilities_i(e,"PAMRasterBand")){const t=function m(e){const t=xmlUtilities_o(e,"NoDataValue"),n=xmlUtilities_e(e,"Histograms/HistItem"),l=xmlUtilities_o(n,"HistMin"),o=xmlUtilities_o(n,"HistMax"),f=xmlUtilities_o(n,"BucketCount"),u=xmlUtilities_t(n,"HistCounts")?.split("|").map((e=>Number(e)));let c,m,d,p;xmlUtilities_n(e,"Metadata/MDI").forEach((e=>{const t=Number(e.textContent??e.nodeValue);switch(e.getAttribute("key").toUpperCase()){case"STATISTICS_MINIMUM":c=t;break;case"STATISTICS_MAXIMUM":m=t;break;case"STATISTICS_MEAN":d=t;break;case"STATISTICS_STDDEV":p=t}}));const S=xmlUtilities_o(e,"Metadata/SourceBandIndex");return{noDataValue:t,histogram:u?.length&&null!=l&&null!=o?{min:l,max:o,size:f||u.length,counts:u}:null,sourceBandIndex:S,statistics:null!=c&&null!=m?{min:c,max:m,avg:d,stddev:p}:null}}(e);null!=t.sourceBandIndex&&null==a.rasterBands[t.sourceBandIndex]?a.rasterBands[t.sourceBandIndex]=t:a.rasterBands.push(t)}}));const i=a.rasterBands;if(i.length){const t=!!i[0].statistics;a.statistics=t?i.map((e=>e.statistics)).filter(arrayUtils.Ru):null;const n=!!i[0].histogram;a.histograms=n?i.map((e=>e.histogram)).filter(arrayUtils.Ru):null}return a}let ImageAuxRaster_h=class extends U{async open(t){await this.init();const e=await this._fetchData(t);let{spatialReference:s,statistics:r,histograms:a,transform:o}=await this._fetchAuxiliaryData(t);const i=!s;i&&(s=new SpatialReference.A({wkid:3857})),a?.length&&null==r&&(r=(0,stretchUtils.Pg)(a));const{width:l,height:m}=e;let c=new Extent.A({xmin:-.5,ymin:.5-m,xmax:l-.5,ymax:.5,spatialReference:s});const h=o?o.forwardTransform(c):c;let d=!0;if(o){const t=o.forwardCoefficients;d=t&&0===t[1]&&0===t[2],d&&(o=null,c=h)}const w=new InMemoryRaster_h({data:{extent:h,nativeExtent:c,transform:o,pixelBlock:e,statistics:r,histograms:a,keyProperties:{DateType:"Processed"},isPseudoSpatialReference:i}});await w.open(),w.data=null,this._set("rasterInfo",w.rasterInfo),this._inMemoryRaster=w}fetchRawTile(t,e,s,r={}){return this._inMemoryRaster.fetchRawTile(t,e,s,r)}async _fetchData(t){const{data:s}=await this.request(this.url,{responseType:"array-buffer",signal:t?.signal}),r=(0,RasterCodec.g)(s).toUpperCase();if("JPG"!==r&&"PNG"!==r&&"GIF"!==r&&"BMP"!==r)throw new core_Error.A("image-aux-raster:open","the data is not a supported format");this._set("datasetFormat",r);const a=r.toLowerCase(),o="gif"===a||"bmp"===a||!(0,has.A)("ios"),i=await this.decodePixelBlock(s,{format:a,useCanvas:o,hasNoZlibMask:!0});if(null==i)throw new core_Error.A("image-aux-raster:open","the data cannot be decoded");return i}async _fetchAuxiliaryData(t){const e=t?.signal,a=this.ioConfig.skipExtensions??[],o=a.includes("aux.xml")?null:this.request(this.url+".aux.xml",{responseType:"xml",signal:e}),i=this.datasetFormat,n="JPG"===i?"jgw":"PNG"===i?"pgw":"BMP"===i?"bpw":null,m=n&&a.includes(n)?null:this.request(this.url.slice(0,this.url.lastIndexOf("."))+"."+n,{responseType:"text",signal:e}),p=await(0,promiseUtils.Lx)([o,m]);if(e?.aborted)throw(0,promiseUtils.NK)();const f=pamParser_S(p[0].value?.data);if(!f.transform){const t=p[1].value?p[1].value.data.split("\n").slice(0,6).map((t=>Number(t))):null;f.transform=6===t?.length?new PolynomialTransform.A({forwardCoefficients:[t[4],t[5],t[0],-t[1],t[2],-t[3]]}):null}return f}};(0,tslib_es6._)([(0,property.MZ)({type:String,json:{write:!0}})],ImageAuxRaster_h.prototype,"datasetFormat",void 0),ImageAuxRaster_h=(0,tslib_es6._)([(0,subclass.$)("esri.layers.support.rasterDatasets.ImageAuxRaster")],ImageAuxRaster_h);const ImageAuxRaster_d=ImageAuxRaster_h;var maybe=__webpack_require__("./node_modules/@arcgis/core/core/maybe.js"),urlUtils=__webpack_require__("./node_modules/@arcgis/core/core/urlUtils.js"),TilemapCache=__webpack_require__("./node_modules/@arcgis/core/layers/support/TilemapCache.js"),GCSShiftTransform=__webpack_require__("./node_modules/@arcgis/core/layers/support/rasterTransforms/GCSShiftTransform.js"),fetchRasterInfo=__webpack_require__("./node_modules/@arcgis/core/rest/imageService/fetchRasterInfo.js");let ImageServerRaster_g=class extends U{constructor(){super(...arguments),this._levelOffset=0,this._tilemapCache=null,this._slices=null,this.datasetFormat="RasterTileServer",this.tileType=null}async open(e){await this.init();const r=e?.signal,a=this.sourceJSON?{data:this.sourceJSON}:await this.request(this.url,{query:{f:"json"},signal:r});a.ssl&&(this.url=this.url.replace(/^http:/i,"https:"));const l=a.data;if(this.sourceJSON=l,!l)throw new core_Error.A("imageserverraster:open","cannot initialize tiled image service, missing service info");if(!l.tileInfo)throw new core_Error.A("imageserverraster:open","use ImageryLayer to open non-tiled image services");this._fixScaleInServiceInfo();this.tileType=l.cacheType,null==this.tileType&&(["jpg","jpeg","png","png8","png24","png32","mixed"].includes(l.tileInfo.format.toLowerCase())?this.tileType="Map":"lerc"===l.tileInfo.format.toLowerCase()?this.tileType="Elevation":this.tileType="Raster"),this.datasetName=l.name?.slice(l.name.indexOf("/")+1)??"";const u=await this._fetchRasterInfo({signal:r});if(null==u)throw new core_Error.A("image-server-raster:open","cannot initialize image service");(0,fetchRasterInfo.E9)(u,l);const h="Map"===this.tileType?function v(e,t){if(!e)return null;const{minScale:i,maxScale:s,minLOD:r,maxLOD:a}=t;if(null!=r&&null!=a)return TileInfo.A.fromJSON({...e,lods:e.lods.filter((({level:e})=>null!=e&&e>=r&&e<=a))});if(0!==i&&0!==s){const t=e=>Math.round(1e4*e)/1e4,r=i?t(i):1/0,a=s?t(s):-1/0;return TileInfo.A.fromJSON({...e,lods:e.lods.filter((e=>{const i=t(e.scale);return i<=r&&i>=a}))})}return TileInfo.A.fromJSON(e)}(l.tileInfo,l):TileInfo.A.fromJSON(l.tileInfo);(0,maybe.Lw)(h);const[p,d]=this._computeMinMaxLOD(u,h),{extent:y,pixelSize:x}=u,g=.5/u.width*x.x,S=Math.max(x.x,x.y),{lods:I}=h;("Map"!==this.tileType&&0!==l.maxScale||Math.abs(x.x-x.y)>g||!I.some((e=>Math.abs(e.resolution-S)<g)))&&(x.x=x.y=p.resolution,u.width=Math.ceil((y.xmax-y.xmin)/x.x-.1),u.height=Math.ceil((y.ymax-y.ymin)/x.y-.1));const w=p.level-d.level,[j,M]=h.size,b=[],T=[];I.forEach(((e,t)=>{e.level>=d.level&&e.level<=p.level&&b.push({x:e.resolution,y:e.resolution}),t<I.length-1&&T.push(Math.round(10*e.resolution/I[t+1].resolution)/10)})),b.sort(((e,t)=>e.x-t.x));const _=this.computeBlockBoundary(y,j,M,h.origin,b,w),O=b.length>1?b.slice(1):null;let R;l.transposeInfo&&(R={tileSize:[l.transposeInfo.rows,l.transposeInfo.cols],packetSize:u.keyProperties?._yxs.PacketSize??0});const z=T.length<=1||T.length>=3&&T.slice(0,-1).every((e=>e===T[0]))?T[0]??2:Math.round(10/(d.resolution/p.resolution)**(-1/w))/10;if(u.storageInfo=new RasterStorageInfo.A({blockWidth:h.size[0],blockHeight:h.size[1],pyramidBlockWidth:h.size[0],pyramidBlockHeight:h.size[1],pyramidResolutions:O,pyramidScalingFactor:z,compression:h.format,origin:h.origin,firstPyramidLevel:1,maximumPyramidLevel:w,tileInfo:h,transposeInfo:R,blockBoundary:_}),this._fixGCSShift(u),this._set("rasterInfo",u),l.capabilities.toLowerCase().includes("tilemap")){const e={tileInfo:u.storageInfo.tileInfo,parsedUrl:(0,urlUtils.An)(this.url),url:this.url,tileServers:[]};this._tilemapCache=new TilemapCache.d({layer:e})}}async fetchRawTile(e,t,i,s={}){const{storageInfo:r,extent:a}=this.rasterInfo,{transposeInfo:l}=r,o=null!=l&&!!s.transposedVariableName;if(this._slices&&!o&&null==s.sliceId)return null;const n=o?0:r.maximumPyramidLevel-e+this._levelOffset,c=`${this.url}/tile/${n}/${t}/${i}`,m=this._slices?o?{variable:s.transposedVariableName}:{sliceId:s.sliceId||0}:null,{data:h}=await this.request(c,{query:m,responseType:"array-buffer",signal:s.signal});if(!h)return null;const f=o?l.tileSize:r.tileInfo.size,p=await this.decodePixelBlock(h,{width:f[0],height:f[1],planes:null,pixelType:null,isPoint:"Elevation"===this.tileType,returnInterleaved:o,noDataValue:this.rasterInfo.noDataValue});if(null==p)return null;const d=r.blockBoundary[e];if("jpg"!==r.compression||i>d.minCol&&i<d.maxCol&&t>d.minRow&&t<d.maxRow)return p;const{origin:y,blockWidth:x,blockHeight:g}=r,{x:v,y:S}=this.getPyramidPixelSize(e),I=Math.round((a.xmin-y.x)/v)%x,w=Math.round((a.xmax-y.x)/v)%x||x,j=Math.round((y.y-a.ymax)/S)%g,M=Math.round((y.y-a.ymin)/S)%g||g,b=i===d.minCol?I:0,T=t===d.minRow?j:0,_=i===d.maxCol?w:x,O=t===d.maxRow?M:g;return(0,pixelUtils.z$)(p,{x:b,y:T},{width:_-b,height:O-T}),p}getSliceIndex(e){if(!this._slices||null==e||0===e.length)return null;const t=e;for(let i=0;i<this._slices.length;i++){const e=this._slices[i].multidimensionalDefinition;if(e.length===t.length&&!e.some((e=>{const i=t.find((t=>e.variableName===t.variableName&&t.dimensionName===e.dimensionName));return!i||(Array.isArray(e.values[0])?`${e.values[0][0]}-${e.values[0][1]}`:e.values[0])!==(Array.isArray(i.values[0])?`${i.values[0][0]}-${i.values[0][1]}`:i.values[0])})))return i}return null}async fetchVariableStatisticsHistograms(e,t){const i=this.request(this.url+"/statistics",{query:{variable:e,f:"json"},signal:t}).then((e=>e.data?.statistics)),s=this.request(this.url+"/histograms",{query:{variable:e,f:"json"},signal:t}).then((e=>e.data?.histograms)),r=await Promise.all([i,s]);return r[0]&&r[0].forEach((e=>{e.avg=e.mean,e.stddev=e.standardDeviation})),r[1]?.[0]?.counts?.length||(r[1]=null),{statistics:r[0]||null,histograms:r[1]||null}}async computeBestPyramidLevelForLocation(e,t={}){if(!this._tilemapCache)return 0;let i=this.identifyPixelLocation(e,0,t.datumTransformation);if(null===i)return null;let s=0;const{maximumPyramidLevel:r}=this.rasterInfo.storageInfo;let a=r-s+this._levelOffset;const l=i.srcLocation;for(;a>=0;){try{if("available"===await this._tilemapCache.fetchAvailability(a,i.row,i.col,t))break}catch{}if(a--,s++,i=this.identifyPixelLocation(l,s,t.datumTransformation),null===i)return null}return-1===a||null==i?null:s}async _fetchRasterInfo(e){const t=this.sourceJSON;if("Map"===this.tileType){const e=t.fullExtent||t.extent,i=Math.ceil((e.xmax-e.xmin)/t.pixelSizeX-.1),s=Math.ceil((e.ymax-e.ymin)/t.pixelSizeY-.1),r=SpatialReference.A.fromJSON(t.spatialReference||e.spatialReference),a=new Point.A({x:t.pixelSizeX,y:t.pixelSizeY,spatialReference:r});return new RasterInfo.A({width:i,height:s,bandCount:3,extent:Extent.A.fromJSON(e),spatialReference:r,pixelSize:a,pixelType:"u8",statistics:null,keyProperties:{DataType:"processed"}})}const{signal:i}=e,s=(0,fetchRasterInfo.Tw)(this.url,this.sourceJSON,{signal:i,query:this.ioConfig.customFetchParameters}),r=t.hasMultidimensions?this.request(`${this.url}/slices`,{query:{f:"json"},signal:i}).then((e=>e.data?.slices)).catch((()=>null)):null,a=await Promise.all([s,r]);return this._slices=a[1],a[0]}_fixScaleInServiceInfo(){const{sourceJSON:e}=this;e.minScale&&e.minScale<0&&(e.minScale=0),e.maxScale&&e.maxScale<0&&(e.maxScale=0)}_fixGCSShift(e){const{extent:t,spatialReference:i}=e;t.xmin>-1&&t.xmax>181&&i?.wkid&&i.isGeographic&&(e.nativeExtent=e.extent,e.transform=new GCSShiftTransform.A,e.extent=e.transform.forwardTransform(t))}_computeMinMaxLOD(e,t){const{pixelSize:i}=e,s=.5/e.width*i.x,{lods:r}=t,a=t.lodAt(Math.max.apply(null,r.map((e=>e.level)))),l=t.lodAt(Math.min.apply(null,r.map((e=>e.level)))),{tileType:o}=this;if("Map"===o)return this._levelOffset=r[0].level,[a,l];if("Raster"===o)return[r.find((e=>e.resolution===i.x))??a,l];const{minScale:n,maxScale:c}=this.sourceJSON;let m=a;c>0&&(m=r.find((e=>Math.abs(e.scale-c)<s)),m||(m=r.filter((e=>e.scale>c)).sort(((e,t)=>e.scale>t.scale?1:-1))[0]??a));let u=l;return n>0&&(u=r.find((e=>Math.abs(e.scale-n)<s))??l,this._levelOffset=u.level-l.level),[m,u]}};(0,tslib_es6._)([(0,property.MZ)({type:String,json:{write:!0}})],ImageServerRaster_g.prototype,"datasetFormat",void 0),(0,tslib_es6._)([(0,property.MZ)()],ImageServerRaster_g.prototype,"tileType",void 0),ImageServerRaster_g=(0,tslib_es6._)([(0,subclass.$)("esri.layers.support.rasterDatasets.ImageServerRaster")],ImageServerRaster_g);const ImageServerRaster_S=ImageServerRaster_g;var rasterFormats_utils=__webpack_require__("./node_modules/@arcgis/core/layers/support/rasterFormats/utils.js");const MRFRaster_y=new Map;MRFRaster_y.set("Int8","s8"),MRFRaster_y.set("UInt8","u8"),MRFRaster_y.set("Int16","s16"),MRFRaster_y.set("UInt16","u16"),MRFRaster_y.set("Int32","s32"),MRFRaster_y.set("UInt32","u32"),MRFRaster_y.set("Float32","f32"),MRFRaster_y.set("Float64","f32"),MRFRaster_y.set("Double64","f32");const MRFRaster_x=new Map;MRFRaster_x.set("none",{blobExtension:".til",isOneSegment:!0,decoderFormat:"bip"}),MRFRaster_x.set("lerc",{blobExtension:".lrc",isOneSegment:!1,decoderFormat:"lerc"}),MRFRaster_x.set("deflate",{blobExtension:".pzp",isOneSegment:!0,decoderFormat:"deflate"}),MRFRaster_x.set("jpeg",{blobExtension:".pjg",isOneSegment:!0,decoderFormat:"jpg"});let w=class extends U{constructor(){super(...arguments),this._files=null,this._storageIndex=null,this.datasetFormat="MRF"}async open(t){await this.init(),this.datasetName=this.url.slice(this.url.lastIndexOf("/")+1);const e=t?t.signal:null,r=await this.request(this.url,{responseType:"xml",signal:e}),{rasterInfo:s,files:o}=this._parseHeader(r.data);if(-1===this.ioConfig.skipExtensions?.indexOf("aux.xml")){const e=await this._fetchAuxiliaryData(t);null!=e&&(s.statistics=e.statistics??s.statistics,s.histograms=e.histograms,e.histograms&&null==s.statistics&&(s.statistics=(0,stretchUtils.Pg)(e.histograms)))}this._set("rasterInfo",s),this._files=o;const i=await this.request(o.index,{responseType:"array-buffer",signal:e});this._storageIndex=this._parseIndex(i.data);const{blockWidth:a,blockHeight:n}=this.rasterInfo.storageInfo,l=this.rasterInfo.storageInfo.pyramidScalingFactor,{width:f,height:c}=this.rasterInfo,p=[],m=this._getBandSegmentCount();let u=0,g=-1;for(;u<this._storageIndex.length;){g++;const t=Math.ceil(f/a/l**g)-1,e=Math.ceil(c/n/l**g)-1;u+=(t+1)*(e+1)*m*4,p.push({maxRow:e,maxCol:t,minCol:0,minRow:0})}this.rasterInfo.storageInfo.blockBoundary=p,g>0&&(this.rasterInfo.storageInfo.firstPyramidLevel=1,this.rasterInfo.storageInfo.maximumPyramidLevel=g),this.updateTileInfo()}async fetchRawTile(t,e,r,s={}){const{blockWidth:i,blockHeight:a,blockBoundary:n}=this.rasterInfo.storageInfo,l=n[t];if(!l||l.maxRow<e||l.maxCol<r||l.minRow>e||l.minCol>r)return null;const{bandCount:f,pixelType:c}=this.rasterInfo,{ranges:p,actualTileWidth:m,actualTileHeight:h}=this._getTileLocation(t,e,r);if(!p||0===p.length)return null;if(0===p[0].from&&0===p[0].to){const t=new Uint8Array(i*a);return new PixelBlock.A({width:i,height:a,pixels:null,mask:t,validPixelCount:0})}const{bandIds:u}=this.ioConfig,g=this._getBandSegmentCount(),d=[];let y=0;for(y=0;y<g;y++)u&&!u.includes(y)||d.push(this.request(this._files.data,{range:{from:p[y].from,to:p[y].to},responseType:"array-buffer",signal:s.signal}));const w=await Promise.all(d),I=w.map((t=>t.data.byteLength)).reduce(((t,e)=>t+e)),b=new Uint8Array(I);let A=0;for(y=0;y<g;y++)b.set(new Uint8Array(w[y].data),A),A+=w[y].data.byteLength;const F=MRFRaster_x.get(this.rasterInfo.storageInfo.compression).decoderFormat,_=await this.decodePixelBlock(b.buffer,{width:i,height:a,format:F,planes:u?.length||f,pixelType:c});if(null==_)return null;let{noDataValue:R}=this.rasterInfo;if(null!=R&&"lerc"!==F&&!_.mask&&(R=R[0],null!=R)){const t=_.width*_.height,e=new Uint8Array(t);if(Math.abs(R)>1e24)for(y=0;y<t;y++)Math.abs((_.pixels[0][y]-R)/R)>1e-6&&(e[y]=1);else for(y=0;y<t;y++)_.pixels[0][y]!==R&&(e[y]=1);_.mask=e}let S=0,j=0;if(m!==i||h!==a){let t=_.mask;if(t)for(y=0;y<a;y++)if(j=y*i,y<h)for(S=m;S<i;S++)t[j+S]=0;else for(S=0;S<i;S++)t[j+S]=0;else for(t=new Uint8Array(i*a),_.mask=t,y=0;y<h;y++)for(j=y*i,S=0;S<m;S++)t[j+S]=1}return _}_parseIndex(t){if(t.byteLength%16>0)throw new Error("invalid array buffer must be multiples of 16");let e,r,s,o,i,a;if(rasterFormats_utils.Z){for(r=new Uint8Array(t),o=new ArrayBuffer(t.byteLength),s=new Uint8Array(o),i=0;i<t.byteLength/4;i++)for(a=0;a<4;a++)s[4*i+a]=r[4*i+3-a];e=new Uint32Array(o)}else e=new Uint32Array(t);return e}_getBandSegmentCount(){return MRFRaster_x.get(this.rasterInfo.storageInfo.compression).isOneSegment?1:this.rasterInfo.bandCount}_getTileLocation(t,e,r){const{blockWidth:s,blockHeight:o,pyramidScalingFactor:i}=this.rasterInfo.storageInfo,{width:a,height:n}=this.rasterInfo,l=this._getBandSegmentCount();let f,c,p,m=0,h=0;for(p=0;p<t;p++)h=i**p,f=Math.ceil(a/s/h),c=Math.ceil(n/o/h),m+=f*c;h=i**t,f=Math.ceil(a/s/h),c=Math.ceil(n/o/h),m+=e*f+r,m*=4*l;const u=this._storageIndex.subarray(m,m+4*l);let g=0,d=0;const y=[];for(let x=0;x<l;x++)g=u[4*x]*2**32+u[4*x+1],d=g+u[4*x+2]*2**32+u[4*x+3],y.push({from:g,to:d});return{ranges:y,actualTileWidth:r<f-1?s:Math.ceil(a/h)-s*(f-1),actualTileHeight:e<c-1?o:Math.ceil(n/h)-o*(c-1)}}_parseHeader(t){const r=xmlUtilities_e(t,"MRF_META/Raster");if(!r)throw new core_Error.A("mrf:open","not a valid MRF format");const s=xmlUtilities_e(r,"Size"),o=parseInt(s.getAttribute("x"),10),n=parseInt(s.getAttribute("y"),10),f=parseInt(s.getAttribute("c"),10),m=(xmlUtilities_t(r,"Compression")||"none").toLowerCase();if(!MRFRaster_x.has(m))throw new core_Error.A("mrf:open","currently does not support compression "+m);const h=xmlUtilities_t(r,"DataType")||"UInt8",w=MRFRaster_y.get(h);if(null==w)throw new core_Error.A("mrf:open","currently does not support pixel type "+h);const I=xmlUtilities_e(r,"PageSize"),b=parseInt(I.getAttribute("x"),10),A=parseInt(I.getAttribute("y"),10),F=xmlUtilities_e(r,"DataValues");let _,R;if(F&&(R=F.getAttribute("NoData"),null!=R&&(_=R.trim().split(" ").map((t=>parseFloat(t))))),xmlUtilities_e(t,"MRF_META/CachedSource"))throw new core_Error.A("mrf:open","currently does not support MRF referencing other data files");const S=xmlUtilities_e(t,"MRF_META/GeoTags"),j=xmlUtilities_e(S,"BoundingBox");let k,M=!1;if(null!=j){const t=parseFloat(j.getAttribute("minx")),e=parseFloat(j.getAttribute("miny")),r=parseFloat(j.getAttribute("maxx")),s=parseFloat(j.getAttribute("maxy")),o=xmlUtilities_t(S,"Projection")||"";let i=SpatialReference.A.WGS84;if("LOCAL_CS[]"!==o)if(o.toLowerCase().startsWith("epsg:")){const t=Number(o.slice(5));isNaN(t)||0===t||(i=new SpatialReference.A({wkid:t}))}else i=d(o)??SpatialReference.A.WGS84;else M=!0,i=new SpatialReference.A({wkid:3857});k=new Extent.A(t,e,r,s),k.spatialReference=i}else M=!0,k=new Extent.A({xmin:-.5,ymin:.5-n,xmax:o-.5,ymax:.5,spatialReference:new SpatialReference.A({wkid:3857})});const T=xmlUtilities_e(t,"MRF_META/Rsets"),C=parseInt(T?.getAttribute("scale")||"2",10),U=k.spatialReference,B=new RasterStorageInfo.A({origin:new Point.A({x:k.xmin,y:k.ymax,spatialReference:U}),blockWidth:b,blockHeight:A,pyramidBlockWidth:b,pyramidBlockHeight:A,compression:m,pyramidScalingFactor:C}),E=new Point.A({x:k.width/o,y:k.height/n,spatialReference:U}),L=new RasterInfo.A({width:o,height:n,extent:k,isPseudoSpatialReference:M,spatialReference:U,bandCount:f,pixelType:w,pixelSize:E,noDataValue:_,storageInfo:B}),P=xmlUtilities_t(t,"datafile"),W=xmlUtilities_t(t,"IndexFile");return{rasterInfo:L,files:{mrf:this.url,index:W||this.url.replace(".mrf",".idx"),data:P||this.url.replace(".mrf",MRFRaster_x.get(m).blobExtension)}}}async _fetchAuxiliaryData(t){try{const{data:e}=await this.request(this.url+".aux.xml",{responseType:"xml",signal:t?.signal});return pamParser_S(e)}catch{return null}}};(0,tslib_es6._)([(0,property.MZ)()],w.prototype,"_files",void 0),(0,tslib_es6._)([(0,property.MZ)()],w.prototype,"_storageIndex",void 0),(0,tslib_es6._)([(0,property.MZ)({type:String,json:{write:!0}})],w.prototype,"datasetFormat",void 0),w=(0,tslib_es6._)([(0,subclass.$)("esri.layers.support.rasterIO.MRFRaster")],w);const I=w;var TiffDecoder=__webpack_require__("./node_modules/@arcgis/core/layers/support/rasterFormats/TiffDecoder.js"),TiffTags=__webpack_require__("./node_modules/@arcgis/core/layers/support/rasterFormats/TiffTags.js");const TIFFRaster_S=(e,t)=>e.get(t)?.values,F=(e,t)=>e.get(t)?.values?.[0];let P=class extends U{constructor(){super(...arguments),this._files=null,this._headerInfo=null,this._bufferSize=1048576,this.datasetFormat="TIFF"}async open(e){await this.init();const t=e?e.signal:null,{data:s}=await this.request(this.url,{range:{from:0,to:this._bufferSize},responseType:"array-buffer",signal:t});if(!s)throw new core_Error.A("tiffraster:open","failed to open url "+this.url);this.datasetName=this.url.slice(this.url.lastIndexOf("/")+1,this.url.lastIndexOf("."));const{littleEndian:a,firstIFDPos:n,isBigTiff:o}=(0,TiffDecoder.uT)(s),f=[];await this._readIFDs(f,s,a,n,0,o?8:4,t);const{imageInfo:l,rasterInfo:u}=this._parseIFDs(f),p=(0,TiffDecoder.zS)(f),d=(0,TiffDecoder.r9)(f);if(this._headerInfo={littleEndian:a,isBigTiff:o,ifds:f,pyramidIFDs:p,maskIFDs:d,...l},this._set("rasterInfo",u),!l.isSupported)throw new core_Error.A("tiffraster:open","this tiff is not supported: "+l.message);if(!l.tileWidth)throw new core_Error.A("tiffraster:open","none-tiled tiff is not optimized for access, convert to COG and retry.");u.isPseudoSpatialReference&&Logger.A.getLogger(this).warn("The spatial reference for this tiff is unsupported. Only EPSG spatial reference codes and Esri WKTs are supported.");const y=f[0].get("PREDICTOR")?.values?.[0],g=f[0].get("SAMPLEFORMAT")?.values?.[0];if(3===g&&2===y)throw new core_Error.A("tiffraster:open","unsupported horizontal difference encoding. Predictor=3 is supported for floatting point data");const{skipExtensions:T=[]}=this.ioConfig;if(!T.includes("aux.xml")){const t=await this._fetchAuxiliaryMetaData(e);null!=t&&this._processPAMInfo(t,u)}T.includes("vat.dbf")||1!==u.bandCount||"u8"!==u.pixelType||(u.attributeTable=await this._fetchAuxiliaryTable(e),null!=u.attributeTable&&(u.keyProperties.DataType="thematic")),this.updateTileInfo()}async fetchRawTile(e,t,r,i={}){if(!this._headerInfo?.isSupported||this.isBlockOutside(e,t,r))return null;const s=await this._fetchRawTiffTile(e,t,r,!1,i);if(null!=s&&this._headerInfo.hasMaskBand){const a=await this._fetchRawTiffTile(e,t,r,!0,i);null!=a&&a.pixels[0]instanceof Uint8Array&&(s.mask=a.pixels[0])}return s}_parseIFDs(e){const t=(0,TiffDecoder.uc)(e),{width:r,height:i,tileWidth:s,tileHeight:a,planes:f,pixelType:l,compression:p,firstPyramidLevel:c,maximumPyramidLevel:h,pyramidBlockWidth:m,pyramidBlockHeight:y,tileBoundary:g,affine:T,metadata:x}=t;let R=d(t.extent.spatialReference?.wkt||t.extent.spatialReference?.wkid),P=!!t.isPseudoGeographic;null==R&&(P=!0,R=new SpatialReference.A({wkid:3857}));const v=new Extent.A({...t.extent,spatialReference:R}),D=new Point.A(v?{x:v.xmin,y:v.ymax,spatialReference:R}:{x:0,y:0}),k=new RasterStorageInfo.A({blockWidth:s,blockHeight:a,pyramidBlockWidth:m,pyramidBlockHeight:y,compression:p,origin:D,firstPyramidLevel:c,maximumPyramidLevel:h,blockBoundary:g}),O=new Point.A({x:(v.xmax-v.xmin)/r,y:(v.ymax-v.ymin)/i,spatialReference:R}),j=x?{BandProperties:x.bandProperties,DataType:x.dataType}:{};let L=null;const B=F(e[0],"PHOTOMETRICINTERPRETATION"),z=TIFFRaster_S(e[0],"COLORMAP");if(B<=3&&z?.length>3&&z.length%3==0){L=[];const e=z.length/3;for(let t=0;t<e;t++)L.push([t,z[t]>>>8,z[t+e]>>>8,z[t+2*e]>>>8])}const A=new RasterInfo.A({width:r,height:i,bandCount:f,pixelType:l,pixelSize:O,storageInfo:k,spatialReference:R,isPseudoSpatialReference:P,keyProperties:j,extent:v,colormap:L,statistics:x?x.statistics:null});return T?.length&&(A.nativeExtent=new Extent.A({xmin:-.5,ymin:.5-i,xmax:r-.5,ymax:.5,spatialReference:R}),A.transform=new PolynomialTransform.A({polynomialOrder:1,forwardCoefficients:[T[2]+T[0]/2,T[5]-T[3]/2,T[0],T[3],-T[1],-T[4]]}),A.extent=A.transform.forwardTransform(A.nativeExtent),A.pixelSize=new Point.A({x:(v.xmax-v.xmin)/r,y:(v.ymax-v.ymin)/i,spatialReference:R}),k.origin.x=-.5,k.origin.y=.5),{imageInfo:t,rasterInfo:A}}_processPAMInfo(e,t){if(t.statistics=e.statistics??t.statistics,t.histograms=e.histograms,e.histograms&&null==t.statistics&&(t.statistics=(0,stretchUtils.Pg)(e.histograms)),e.transform&&null==t.transform){t.transform=e.transform,t.nativeExtent=t.extent;const r=t.transform.forwardTransform(t.nativeExtent);t.pixelSize=new Point.A({x:(r.xmax-r.xmin)/t.width,y:(r.ymax-r.ymin)/t.height,spatialReference:t.spatialReference}),t.extent=r}t.isPseudoSpatialReference&&e.spatialReference&&(t.spatialReference=e.spatialReference,t.extent.spatialReference=t.nativeExtent.spatialReference=t.storageInfo.origin.spatialReference=t.spatialReference)}async _readIFDs(e,t,r,i,s,a=4,n){if(!i)return null;(i>=t.byteLength||i<0)&&(t=(await this.request(this.url,{range:{from:i+s,to:i+s+this._bufferSize},responseType:"array-buffer",signal:n})).data,s=i+s,i=0);const o=await this._readIFD(t,r,i,s,TiffTags.A.tiffTags,a,n);if(e.push(o.ifd),!o.nextIFD)return null;await this._readIFDs(e,t,r,o.nextIFD-s,s,a,n)}async _readIFD(e,r,i,s,a=TiffTags.A.tiffTags,n=4,o){if(!e)return null;const f=(0,TiffDecoder.JM)(e,r,i,s,a,n);if(f.success){const i=[];if(f.ifd?.forEach((e=>{e.values||i.push(e)})),i.length>0){const a=i.map((e=>e.offlineOffsetSize)).filter(arrayUtils.Ru),n=Math.min.apply(null,a.map((e=>e[0])));if(Math.min.apply(null,a.map((e=>e[0]+e[1])))-n<=this._bufferSize){const{data:t}=await this.request(this.url,{range:{from:n,to:n+this._bufferSize},responseType:"array-buffer",signal:o});e=t,s=n,i.forEach((t=>(0,TiffDecoder.Cr)(e,r,t,s)))}}if(f.ifd?.has("GEOKEYDIRECTORY")){const t=f.ifd.get("GEOKEYDIRECTORY"),i=t?.values;if(i&&i.length>4){const a=i[0]+"."+i[1]+"."+i[2],n=await this._readIFD(e,r,t.valueOffset+6-s,s,TiffTags.A.geoKeys,2,o);t.data=n.ifd,t.data&&t.data.set("GEOTIFFVersion",{id:0,type:2,valueCount:1,valueOffset:null,values:[a]})}}return f}if(f.requiredBufferSize&&f.requiredBufferSize!==e.byteLength){const t=await this.request(this.url,{range:{from:s,to:s+f.requiredBufferSize+4},responseType:"array-buffer",signal:o});return(e=t.data).byteLength<f.requiredBufferSize?null:this._readIFD(e,r,0,s,TiffTags.A.tiffTags,4,o)}}async _fetchRawTiffTile(e,t,r,i,s={}){const a=this._getTileLocation(e,t,r,i);if(!a)return null;const{ranges:n,actualTileWidth:o,actualTileHeight:f,ifd:l}=a,u=n.map((e=>this.request(this.url,{range:e,responseType:"array-buffer",signal:s.signal}))),p=await Promise.all(u),c=p.map((e=>e.data.byteLength)).reduce(((e,t)=>e+t)),h=1===p.length?p[0].data:new ArrayBuffer(c),m=[0],d=[0];if(p.length>1){const e=new Uint8Array(h);for(let t=0,r=0;t<p.length;t++){const i=p[t].data;e.set(new Uint8Array(i),r),m[t]=r,r+=i.byteLength,d[t]=i.byteLength}}const{blockWidth:y,blockHeight:g}=this.getBlockWidthHeight(e),T=await this.decodePixelBlock(h,{format:"tiff",customOptions:{headerInfo:this._headerInfo,ifd:l,offsets:m,sizes:d},width:y,height:g,planes:null,pixelType:null});if(null==T)return null;let x,I,w;if(o!==y||f!==g){let e=T.mask;if(e)for(x=0;x<g;x++)if(w=x*y,x<f)for(I=o;I<y;I++)e[w+I]=0;else for(I=0;I<y;I++)e[w+I]=0;else for(e=new Uint8Array(y*g),T.mask=e,x=0;x<f;x++)for(w=x*y,I=0;I<o;I++)e[w+I]=1}return T}_getTileLocation(e,t,r,i=!1){const{firstPyramidLevel:s,blockBoundary:a}=this.rasterInfo.storageInfo,n=0===e?0:e-(s-1),{_headerInfo:o}=this;if(!o)return null;const f=i?o.maskIFDs[n]:0===n?o?.ifds[0]:o?.pyramidIFDs[n-1];if(!f)return null;const l=(0,TiffDecoder.XO)(f,o),u=TIFFRaster_S(f,"TILEOFFSETS");if(void 0===u)return null;const p=TIFFRaster_S(f,"TILEBYTECOUNTS"),{minRow:c,minCol:h,maxRow:m,maxCol:d}=a[n];if(t>m||r>d||t<c||r<h)return null;const y=F(f,"IMAGEWIDTH"),g=F(f,"IMAGELENGTH"),x=F(f,"TILEWIDTH"),I=F(f,"TILELENGTH"),w=[];if(l){const{bandCount:e}=this.rasterInfo;for(let i=0;i<e;i++){const e=i*(m+1)*(d+1)+t*(d+1)+r;w[i]={from:u[e],to:u[e]+p[e]-1}}}else{const e=t*(d+1)+r;w.push({from:u[e],to:u[e]+p[e]-1})}for(let T=0;T<w.length;T++)if(null==w[T].from||!w[T].to||w[T].to<0)return null;return{ranges:w,ifd:f,actualTileWidth:r===d&&y%x||x,actualTileHeight:t===m&&g%I||I}}async _fetchAuxiliaryMetaData(e){try{const{data:t}=await this.request(this.url+".aux.xml",{responseType:"xml",signal:e?.signal});return pamParser_S(t)}catch{return null}}async _fetchAuxiliaryTable(e){try{const{data:t}=await this.request(this.url+".vat.dbf",{responseType:"array-buffer",signal:e?.signal}),r=DBFParser_r.parse(t);return r?.recordSet?FeatureSet.A.fromJSON(r.recordSet):null}catch{return null}}};(0,tslib_es6._)([(0,property.MZ)()],P.prototype,"_files",void 0),(0,tslib_es6._)([(0,property.MZ)()],P.prototype,"_headerInfo",void 0),(0,tslib_es6._)([(0,property.MZ)()],P.prototype,"_bufferSize",void 0),(0,tslib_es6._)([(0,property.MZ)({type:String,json:{write:!0}})],P.prototype,"datasetFormat",void 0),P=(0,tslib_es6._)([(0,subclass.$)("esri.layers.support.rasterDatasets.TIFFRaster")],P);const TIFFRaster_v=P,RasterFactory_c=new Map;RasterFactory_c.set("CRF",{desc:"Cloud Raster Format",constructor:S}),RasterFactory_c.set("MRF",{desc:"Meta Raster Format",constructor:I}),RasterFactory_c.set("TIFF",{desc:"GeoTIFF",constructor:TIFFRaster_v}),RasterFactory_c.set("RasterTileServer",{desc:"Raster Tile Server",constructor:ImageServerRaster_S}),RasterFactory_c.set("JPG",{desc:"JPG Raster Format",constructor:ImageAuxRaster_d}),RasterFactory_c.set("PNG",{desc:"PNG Raster Format",constructor:ImageAuxRaster_d}),RasterFactory_c.set("GIF",{desc:"GIF Raster Format",constructor:ImageAuxRaster_d}),RasterFactory_c.set("BMP",{desc:"BMP Raster Format",constructor:ImageAuxRaster_d});class RasterFactory_n{static get supportedFormats(){const t=new Set;return RasterFactory_c.forEach(((e,r)=>t.add(r))),t}static async open(e){const{url:r,ioConfig:s,sourceJSON:o}=e;let a=e.datasetFormat;null==a&&r.lastIndexOf(".")&&(a=r.slice(r.lastIndexOf(".")+1).toUpperCase()),"OVR"===a||"TIF"===a?a="TIFF":"JPG"!==a&&"JPEG"!==a&&"JFIF"!==a||(a="JPG"),r.toLowerCase().includes("/imageserver")&&!r.toLowerCase().includes("/wcsserver")&&(a="RasterTileServer");const n={url:r,sourceJSON:o,datasetFormat:a,ioConfig:s??{bandIds:null,sampling:null}};let l,i;if(a&&this.supportedFormats.has(a)){if("CRF"===a&&!s?.enableCRF)throw new core_Error.A("rasterfactory:open",`cannot open raster: ${r}`);return l=RasterFactory_c.get(a).constructor,i=new l(n),await i.open({signal:e.signal}),i}if(a)throw new core_Error.A("rasterfactory:open","not a supported format "+a);const u=Array.from(RasterFactory_c.keys());let F=0;const m=()=>(a=u[F++],a&&("CRF"!==a||s?.enableCRF)?(l=RasterFactory_c.get(a).constructor,i=new l(n),i.open({signal:e.signal}).then((()=>i)).catch((()=>m()))):null);return m()}static register(t,e,r){RasterFactory_c.has(t.toUpperCase())||RasterFactory_c.set(t.toUpperCase(),{desc:e,constructor:r})}}var popupUtils=__webpack_require__("./node_modules/@arcgis/core/support/popupUtils.js"),interfaces=__webpack_require__("./node_modules/@arcgis/core/webdoc/interfaces.js");let E=class extends((0,BlendLayer.d)((0,ScaleRangeLayer.j)((0,OperationalLayer.q)((0,PortalLayer.A)((0,CustomParametersMixin.d)(ImageryTileMixin_V((0,TemporalLayer.e)((0,ArcGISService.b)((0,RefreshableLayer.J)((0,MultiOriginJSONSupport.P)((0,Clonable.O)(Layer.A)))))))))))){constructor(...e){super(...e),this._primaryRasters=[],this.bandIds=null,this.interpolation=null,this.legendEnabled=!0,this.isReference=null,this.listMode="show",this.sourceJSON=null,this.version=null,this.type="imagery-tile",this.operationalLayerType="ArcGISTiledImageServiceLayer",this.popupEnabled=!0,this.popupTemplate=null,this.fields=null,this._debouncedSaveOperations=(0,promiseUtils.sg)((async(e,r,t)=>{const{save:s,saveAs:i}=await __webpack_require__.e(45144).then(__webpack_require__.bind(__webpack_require__,"./node_modules/@arcgis/core/layers/save/imageryUtils.js"));switch(e){case interfaces.X.SAVE:return s(this,r);case interfaces.X.SAVE_AS:return i(this,t,r)}}))}normalizeCtorArgs(e,r){return"string"==typeof e?{url:e,...r}:e}load(e){const r=null!=e?e.signal:null;return this.addResolvingPromise(this.loadFromPortal({supportedTypes:["Image Service"]},e).catch(promiseUtils.QP).then((()=>this._openRaster(r)))),Promise.resolve(this)}get defaultPopupTemplate(){return this.createPopupTemplate()}get rasterFields(){const e=[new Field.A({name:"Raster.ServicePixelValue",alias:"Pixel Value",domain:null,editable:!1,length:50,type:"string"}),new Field.A({name:"Raster.ServicePixelValue.Raw",alias:"Raw Pixel Value",domain:null,editable:!1,length:50,type:"string"})],{rasterInfo:r}=this,t=r?.attributeTable,s=null!=t?t.fields:null;if(s){const r=s.filter((e=>"oid"!==e.type&&"value"!==e.name.toLowerCase())).map((e=>{const r=e.clone();return r.name="Raster."+e.name,r}));e.push(...r)}const o=r?.dataType,a=r?.multidimensionalInfo;if(("vector-magdir"===o||"vector-uv"===o)&&null!=a){const r=a.variables[0].unit?.trim(),t="Magnitude"+(r?` (${r})`:"");e.push(new Field.A({name:"Raster.Magnitude",alias:t,domain:null,editable:!1,type:"double"})),e.push(new Field.A({name:"Raster.Direction",alias:"Direction (°)",domain:null,editable:!1,type:"double"}))}return e}createPopupTemplate(e){const{rasterFields:r}=this,t=new Set(r.map((({name:e})=>e)).filter((e=>"raster.servicepixelvalue.raw"!==e.toLowerCase())));return(0,popupUtils.tn)({fields:r,title:this.title},{...e,visibleFieldNames:t})}async generateRasterInfo(e,r){if(!(e=(0,ensureType.PZ)(RasterFunction.A,e)))return this.rasterInfo;try{const t={raster:this._primaryRasters[0]};this._primaryRasters.length>1&&this._primaryRasters.forEach((e=>t[e.url]=e));const s=(0,rasterFunctionHelper.vt)(e.functionDefinition?.toJSON()??e.toJSON(),t),i=new c({rasterFunction:s});return await i.open(r),i.rasterInfo}catch(t){if(t instanceof core_Error.A)throw t;throw new core_Error.A("imagery-tile-layer","the given raster function is not supported")}}async save(e){return this._debouncedSaveOperations(interfaces.X.SAVE,e)}async saveAs(e,r){return this._debouncedSaveOperations(interfaces.X.SAVE_AS,r,e)}write(e,r){const t=this._primaryRasters[0]??this.raster;if(this.loaded?"RasterTileServer"===t.datasetFormat&&("Raster"===t.tileType||"Map"===t.tileType):this.url&&/\/ImageServer(\/|\/?$)/i.test(this.url))return super.write(e,r);if(r?.messages){const e=`${r.origin}/${r.layerContainerType||"operational-layers"}`;r.messages.push(new core_Error.A("layer:unsupported",`Layers (${this.title}, ${this.id}) of type '${this.declaredClass}' are not supported in the context of '${e}'`,{layer:this}))}return null}async _openRaster(e){let r=!1;if(this.raster)this.raster.rasterInfo||await this.raster.open(),"Function"===this.raster.datasetFormat?(r=!0,this._primaryRasters=this.raster.primaryRasters.rasters):this._primaryRasters=[this.raster],this.url=this.raster.url;else{const{rasterFunction:r}=this,t=[this.url];r&&(0,rasterFunctionHelper.UD)(r.toJSON(),t);const a=await Promise.all(t.map((r=>RasterFactory_n.open({url:r,sourceJSON:this.sourceJSON,ioConfig:{sampling:"closest",...this.ioConfig,customFetchParameters:this.customParameters},signal:e})))),n=a.findIndex((e=>null==e));if(n>-1)throw new core_Error.A("imagery-tile-layer:open",`cannot open raster: ${t[n]}`);if(this._primaryRasters=a,r){const e={raster:this._primaryRasters[0]};this._primaryRasters.length>1&&this._primaryRasters.forEach((r=>e[r.url]=r));const t=(0,rasterFunctionHelper.vt)(r.functionDefinition?.toJSON()??r.toJSON(),e),n=new c({rasterFunction:t});try{await n.open(),this.raster=n}catch(o){const e=Logger.A.getLogger(this);o instanceof core_Error.A&&e.error("imagery-tile-layer:open",o.message),e.warn("imagery-tile-layer:open","the raster function cannot be applied and is removed"),this._set("rasterFunction",null),this.raster=a[0]}}else this.raster=a[0]}const t=this.raster.rasterInfo;if(!t)throw new core_Error.A("imagery-tile-layer:load","cannot load resources on "+this.url);if(this._set("rasterInfo",r?t:this._primaryRasters[0].rasterInfo),this._set("spatialReference",t.spatialReference),this.sourceJSON=this.sourceJSON||this.raster.sourceJSON,null!=this.sourceJSON){const e="Map"===this.raster.tileType&&null!=this.sourceJSON.minLOD&&null!=this.sourceJSON.maxLOD?this.sourceJSON:{...this.sourceJSON,minScale:0,maxScale:0};this.read(e,{origin:"service"})}else this.read({tileInfo:this.rasterInfo.storageInfo.tileInfo.toJSON()},{origin:"service"});this.title||(this.title=this.raster.datasetName),"Map"===this.raster.tileType&&(this.popupEnabled=!1),this._configDefaultSettings(),this.addHandles((0,reactiveUtils.wB)((()=>this.customParameters),(e=>{this.raster&&(this.raster.ioConfig.customFetchParameters=e)})))}};(0,tslib_es6._)([(0,property.MZ)({clonable:!1})],E.prototype,"_primaryRasters",void 0),(0,tslib_es6._)([(0,property.MZ)({type:[ensureType.jz],json:{write:{overridePolicy(){return{enabled:!this.loaded||"Raster"===this.raster.tileType||"0,1,2"!==this.bandIds?.join(",")}}}}})],E.prototype,"bandIds",void 0),(0,tslib_es6._)([(0,property.MZ)({json:{write:{overridePolicy(){return{enabled:!this.loaded||"Raster"===this.raster.tileType||"bilinear"!==this.interpolation}}}}}),(0,enumeration.e)(rasterEnums.SZ)],E.prototype,"interpolation",void 0),(0,tslib_es6._)([(0,property.MZ)(commonProperties.fV)],E.prototype,"legendEnabled",void 0),(0,tslib_es6._)([(0,property.MZ)({type:Boolean,json:{read:!1,write:{enabled:!0,overridePolicy:()=>({enabled:!1})}}})],E.prototype,"isReference",void 0),(0,tslib_es6._)([(0,property.MZ)({type:["show","hide"]})],E.prototype,"listMode",void 0),(0,tslib_es6._)([(0,property.MZ)({json:{read:!0,write:!0}})],E.prototype,"blendMode",void 0),(0,tslib_es6._)([(0,property.MZ)()],E.prototype,"sourceJSON",void 0),(0,tslib_es6._)([(0,property.MZ)({readOnly:!0,json:{origins:{service:{read:{source:"currentVersion"}}}}})],E.prototype,"version",void 0),(0,tslib_es6._)([(0,property.MZ)({readOnly:!0,json:{read:!1}})],E.prototype,"type",void 0),(0,tslib_es6._)([(0,property.MZ)({type:["ArcGISTiledImageServiceLayer"]})],E.prototype,"operationalLayerType",void 0),(0,tslib_es6._)([(0,property.MZ)({type:Boolean,value:!0,json:{read:{source:"disablePopup",reader:(e,r)=>!r.disablePopup},write:{target:"disablePopup",overridePolicy(){return{enabled:!this.loaded||"Raster"===this.raster.tileType}},writer(e,r,t){r[t]=!e}}}})],E.prototype,"popupEnabled",void 0),(0,tslib_es6._)([(0,property.MZ)({type:PopupTemplate.A,json:{read:{source:"popupInfo"},write:{target:"popupInfo",overridePolicy(){return{enabled:!this.loaded||"Raster"===this.raster.tileType}}}}})],E.prototype,"popupTemplate",void 0),(0,tslib_es6._)([(0,property.MZ)({readOnly:!0})],E.prototype,"defaultPopupTemplate",null),(0,tslib_es6._)([(0,property.MZ)({readOnly:!0,type:[Field.A]})],E.prototype,"fields",void 0),(0,tslib_es6._)([(0,property.MZ)({readOnly:!0,type:[Field.A]})],E.prototype,"rasterFields",null),E=(0,tslib_es6._)([(0,subclass.$)("esri.layers.ImageryTileLayer")],E);const A=E},"./node_modules/@arcgis/core/layers/support/rasterDatasets/RawBlockCache.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{jX:()=>s,zo:()=>h,gd:()=>m,ph:()=>i,no:()=>x,kz:()=>u,ht:()=>a,yo:()=>g});__webpack_require__("./node_modules/@arcgis/core/geometry.js");var rasterProjectionHelper=__webpack_require__("./node_modules/@arcgis/core/layers/support/rasterFunctions/rasterProjectionHelper.js"),Point=__webpack_require__("./node_modules/@arcgis/core/geometry/Point.js");const r=new Map,c=new class t{constructor(t=15e3,e=5e3){this._timer=null,this._cachedBlocks=new Map,this._size=-1,this._duration=t,this._interval=Math.min(t,e)}decreaseRefCount(t,e){const s=t+"/"+e,r=this._cachedBlocks;if(r.has(s)){const t=r.get(s);return t.refCount--,t.refCount<=0&&(r.delete(s),t.controller&&t.controller.abort()),t.refCount}return 0}getBlock(t,e){const s=t+"/"+e,r=this._cachedBlocks;if(r.has(s)){const t=r.get(s);return t.ts=Date.now(),t.refCount++,r.delete(s),r.set(s,t),t.block}return null}putBlock(t,e,s,r){const i=this._cachedBlocks,c=t+"/"+e;if(i.has(c)){const t=i.get(c);t.ts=Date.now(),t.refCount++}else i.set(c,{block:s,ts:Date.now(),refCount:1,controller:r});this._trim(),this._updateTimer()}deleteBlock(t,e){const s=this._cachedBlocks,r=t+"/"+e;s.has(r)&&s.delete(r)}updateMaxSize(t){this._size=t,this._trim()}empty(){this._cachedBlocks.clear(),this._clearTimer()}getCurrentSize(){return this._cachedBlocks.size}_updateTimer(){if(null!=this._timer)return;const t=this._cachedBlocks;this._timer=setInterval((()=>{const e=Array.from(t),s=Date.now();for(let r=0;r<e.length&&e[r][1].ts<=s-this._duration;r++)t.delete(e[r][0]);0===t.size&&this._clearTimer()}),this._interval)}_trim(){const t=this._cachedBlocks;if(-1===this._size||this._size>=t.size)return;const e=Array.from(t);for(let s=0;s<e.length-this._size;s++)t.delete(e[s][0])}_clearTimer(){null!=this._timer&&(clearInterval(this._timer),this._timer=null)}};function i(e,t){return null==t?e:`${e}?sliceId=${t}`}function u(e,t){const n={extent:null,rasterInfo:t,cache:new Map},o=r.get(e);return o?(o.push(n),o.length-1):(r.set(e,[n]),0)}function a(e,t){const n=r.get(e);n&&(n[t]=null,n.some((e=>null!=e))||r.delete(e))}function s(e,t,n){const o=r.get(e);if(!o)return null==t?c.decreaseRefCount(e,n):0;if(null==t||null==o[t])return c.decreaseRefCount(e,n);const l=o[t]?.cache,i=l?.get(n);if(l&&i){if(i.refCount--,0===i.refCount){l.delete(n);for(let e=0;e<o.length;e++)o[e]?.cache.delete(n);i.controller&&i.controller.abort()}return i.refCount}return 0}function m(e,t,n){const o=r.get(e);if(!o)return null==t?c.getBlock(e,n):null;if(null==t||null==o[t]){for(let e=0;e<o.length;e++){const t=o[e]?.cache.get(n);if(t)return t.refCount++,t.block}return c.getBlock(e,n)}const l=o[t]?.cache.get(n);if(l)return l.refCount++,l.block;for(let r=0;r<o.length;r++){if(r===t||!o[r])continue;const e=o[r]?.cache,l=e?.get(n);if(e&&l)return l.refCount++,e.set(n,l),l.block}return null}function x(e,t,n,o,l=null){const i=r.get(e);if(!i)return void(null==t&&c.putBlock(e,n,o,l));if(null==t||null==i[t])return void c.putBlock(e,n,o,l);const u={refCount:1,block:o,isResolved:!1,isRejected:!1,controller:l};o.then((()=>u.isResolved=!0)).catch((()=>u.isRejected=!0)),i[t]?.cache.set(n,u)}function h(e,t,n){const o=r.get(e);o?null!=t&&null!=o[t]?o[t]?.cache.delete(n):c.deleteBlock(e,n):null==t&&c.deleteBlock(e,n)}function d(e,t){const n=r.get(e);return n?n[t]??null:null}function g(e,r,c,i,u,a,f=null){const s=d(e,r);if(!s)return;const m=s.extent,{cache:x,rasterInfo:h}=s;if(m&&m.xmin===c.xmin&&m.xmax===c.xmax&&m.ymin===c.ymin&&m.ymax===c.ymax)return;i=i??0;const g=c.clone().normalize(),{spatialReference:y,transform:p}=h,k=new Set;for(let d=0;d<g.length;d++){const e=g[d];if(e.xmax-e.xmin<=i||e.ymax-e.ymin<=i)continue;let r=(0,rasterProjectionHelper._l)(e,y,f);null!=p&&(r=p.inverseTransform(r));const c=new Point.A({x:i,y:i,spatialReference:e.spatialReference});if(null==u&&!(u=(0,rasterProjectionHelper.Wo)(c,y,e,f)))return;const{pyramidLevel:s,pyramidResolution:m,excessiveReading:x}=(0,rasterProjectionHelper.t$)(u,h,a||"closest");if(x)return;const{storageInfo:M}=h,{origin:R}=M,C={x:Math.max(0,Math.floor((r.xmin-R.x)/m.x)),y:Math.max(0,Math.floor((R.y-r.ymax)/m.y))},B=Math.ceil((r.xmax-r.xmin)/m.x-.1),j=Math.ceil((r.ymax-r.ymin)/m.y-.1),v=s>0?M.pyramidBlockWidth:M.blockWidth,b=s>0?M.pyramidBlockHeight:M.blockHeight,w=1,$=Math.max(0,Math.floor(C.x/v)-w),I=Math.max(0,Math.floor(C.y/b)-w),H=Math.floor((C.x+B-1)/v)+w,E=Math.floor((C.y+j-1)/b)+w;for(let t=I;t<=E;t++)for(let e=$;e<=H;e++)k.add(`${s}/${t}/${e}`)}x.forEach(((e,t)=>{if(!k.has(t)){const e=x.get(t);(null==e||e.isResolved||e.isRejected)&&x.delete(t)}})),s.extent={xmin:c.xmin,ymin:c.ymin,xmax:c.xmax,ymax:c.ymax}}}}]);